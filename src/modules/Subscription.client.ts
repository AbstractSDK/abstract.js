/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.11.1.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from '@cosmjs/cosmwasm-stargate'
import { Coin, StdFee } from '@cosmjs/amino'
import {
  Addr,
  AddOnState,
  Memory,
  AssetInfoBaseForAddr,
  AssetInfoBaseForString,
  BaseResponse,
  Decimal,
  Uint128,
  EmissionType,
  ConfigResponse,
  ContributionConfig,
  SubscriptionConfig,
  Uint64,
  ContributorStateResponse,
  Compensation,
  ExecuteMsg,
  AddOnExecuteMsg,
  Binary,
  Cw20ReceiveMsg,
  FeeResponse,
  AssetBaseForAddr,
  UncheckedEmissionType,
  InstantiateMsg,
  AddOnInstantiateMsg,
  ContributionInstantiateMsg,
  SubscriptionInstantiateMsg,
  QueryMsg,
  AddOnQueryMsg,
  StateResponse,
  ContributionState,
  SubscriptionState,
  SubscriberStateResponse,
  Subscriber,
} from './Subscription.types'
export interface SubscriptionReadOnlyInterface {
  contractAddress: string
  queryBase: () => Promise<BaseResponse>
  state: () => Promise<StateResponse>
  config: () => Promise<ConfigResponse>
  fee: () => Promise<FeeResponse>
  subscriberState: ({ osId }: { osId: number }) => Promise<SubscriberStateResponse>
  contributorState: ({ osId }: { osId: number }) => Promise<ContributorStateResponse>
}
export class SubscriptionQueryClient implements SubscriptionReadOnlyInterface {
  client: CosmWasmClient
  contractAddress: string

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client
    this.contractAddress = contractAddress
    this.queryBase = this.queryBase.bind(this)
    this.state = this.state.bind(this)
    this.config = this.config.bind(this)
    this.fee = this.fee.bind(this)
    this.subscriberState = this.subscriberState.bind(this)
    this.contributorState = this.contributorState.bind(this)
  }

  queryBase = async (): Promise<BaseResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      base: {},
    })
  }
  state = async (): Promise<StateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      state: {},
    })
  }
  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {},
    })
  }
  fee = async (): Promise<FeeResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      fee: {},
    })
  }
  subscriberState = async ({ osId }: { osId: number }): Promise<SubscriberStateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      subscriber_state: {
        os_id: osId,
      },
    })
  }
  contributorState = async ({ osId }: { osId: number }): Promise<ContributorStateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      contributor_state: {
        os_id: osId,
      },
    })
  }
}
export interface SubscriptionInterface extends SubscriptionReadOnlyInterface {
  contractAddress: string
  sender: string
  base: (
    msg: AddOnExecuteMsg,
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  receive: (
    {
      amount,
      msg,
      sender,
    }: {
      amount: Uint128
      msg: Binary
      sender: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  pay: (
    {
      osId,
    }: {
      osId: number
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  unsubscribe: (
    {
      osIds,
    }: {
      osIds: number[]
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  claimCompensation: (
    {
      osId,
    }: {
      osId: number
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  claimEmissions: (
    {
      osId,
    }: {
      osId: number
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  updateContributor: (
    {
      basePerBlock,
      contributorOsId,
      expirationBlock,
      weight,
    }: {
      basePerBlock?: Decimal
      contributorOsId: number
      expirationBlock?: Uint64
      weight?: Uint64
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  removeContributor: (
    {
      osId,
    }: {
      osId: number
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  updateSubscriptionConfig: (
    {
      factoryAddress,
      paymentAsset,
      subscriptionCost,
      versionControlAddress,
    }: {
      factoryAddress?: string
      paymentAsset?: AssetInfoBaseForString
      subscriptionCost?: Decimal
      versionControlAddress?: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
  updateContributionConfig: (
    {
      emissionUserShare,
      emissionsAmpFactor,
      emissionsOffset,
      maxEmissionsMultiple,
      projectTokenInfo,
      protocolIncomeShare,
    }: {
      emissionUserShare?: Decimal
      emissionsAmpFactor?: Uint128
      emissionsOffset?: Uint128
      maxEmissionsMultiple?: Decimal
      projectTokenInfo?: AssetInfoBaseForString
      protocolIncomeShare?: Decimal
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: Coin[]
  ) => Promise<ExecuteResult>
}
export class SubscriptionClient extends SubscriptionQueryClient implements SubscriptionInterface {
  client: SigningCosmWasmClient
  sender: string
  contractAddress: string

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress)
    this.client = client
    this.sender = sender
    this.contractAddress = contractAddress
    this.base = this.base.bind(this)
    this.receive = this.receive.bind(this)
    this.pay = this.pay.bind(this)
    this.unsubscribe = this.unsubscribe.bind(this)
    this.claimCompensation = this.claimCompensation.bind(this)
    this.claimEmissions = this.claimEmissions.bind(this)
    this.updateContributor = this.updateContributor.bind(this)
    this.removeContributor = this.removeContributor.bind(this)
    this.updateSubscriptionConfig = this.updateSubscriptionConfig.bind(this)
    this.updateContributionConfig = this.updateContributionConfig.bind(this)
  }

  base = async (
    msg: AddOnExecuteMsg,
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        base: msg,
      },
      fee,
      memo,
      funds
    )
  }
  receive = async (
    {
      amount,
      msg,
      sender,
    }: {
      amount: Uint128
      msg: Binary
      sender: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        receive: {
          amount,
          msg,
          sender,
        },
      },
      fee,
      memo,
      funds
    )
  }
  pay = async (
    {
      osId,
    }: {
      osId: number
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        pay: {
          os_id: osId,
        },
      },
      fee,
      memo,
      funds
    )
  }
  unsubscribe = async (
    {
      osIds,
    }: {
      osIds: number[]
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        unsubscribe: {
          os_ids: osIds,
        },
      },
      fee,
      memo,
      funds
    )
  }
  claimCompensation = async (
    {
      osId,
    }: {
      osId: number
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        claim_compensation: {
          os_id: osId,
        },
      },
      fee,
      memo,
      funds
    )
  }
  claimEmissions = async (
    {
      osId,
    }: {
      osId: number
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        claim_emissions: {
          os_id: osId,
        },
      },
      fee,
      memo,
      funds
    )
  }
  updateContributor = async (
    {
      basePerBlock,
      contributorOsId,
      expirationBlock,
      weight,
    }: {
      basePerBlock?: Decimal
      contributorOsId: number
      expirationBlock?: Uint64
      weight?: Uint64
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_contributor: {
          base_per_block: basePerBlock,
          contributor_os_id: contributorOsId,
          expiration_block: expirationBlock,
          weight,
        },
      },
      fee,
      memo,
      funds
    )
  }
  removeContributor = async (
    {
      osId,
    }: {
      osId: number
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        remove_contributor: {
          os_id: osId,
        },
      },
      fee,
      memo,
      funds
    )
  }
  updateSubscriptionConfig = async (
    {
      factoryAddress,
      paymentAsset,
      subscriptionCost,
      versionControlAddress,
    }: {
      factoryAddress?: string
      paymentAsset?: AssetInfoBaseForString
      subscriptionCost?: Decimal
      versionControlAddress?: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_subscription_config: {
          factory_address: factoryAddress,
          payment_asset: paymentAsset,
          subscription_cost: subscriptionCost,
          version_control_address: versionControlAddress,
        },
      },
      fee,
      memo,
      funds
    )
  }
  updateContributionConfig = async (
    {
      emissionUserShare,
      emissionsAmpFactor,
      emissionsOffset,
      maxEmissionsMultiple,
      projectTokenInfo,
      protocolIncomeShare,
    }: {
      emissionUserShare?: Decimal
      emissionsAmpFactor?: Uint128
      emissionsOffset?: Uint128
      maxEmissionsMultiple?: Decimal
      projectTokenInfo?: AssetInfoBaseForString
      protocolIncomeShare?: Decimal
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_contribution_config: {
          emission_user_share: emissionUserShare,
          emissions_amp_factor: emissionsAmpFactor,
          emissions_offset: emissionsOffset,
          max_emissions_multiple: maxEmissionsMultiple,
          project_token_info: projectTokenInfo,
          protocol_income_share: protocolIncomeShare,
        },
      },
      fee,
      memo,
      funds
    )
  }
}
