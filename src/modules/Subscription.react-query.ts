/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.11.1.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from '@tanstack/react-query'
import { ExecuteResult } from '@cosmjs/cosmwasm-stargate'
import { StdFee, Coin } from '@cosmjs/amino'
import {
  Addr,
  AddOnState,
  Memory,
  AssetInfoBaseForAddr,
  AssetInfoBaseForString,
  BaseResponse,
  Decimal,
  Uint128,
  EmissionType,
  ConfigResponse,
  ContributionConfig,
  SubscriptionConfig,
  Uint64,
  ContributorStateResponse,
  Compensation,
  ExecuteMsg,
  AddOnExecuteMsg,
  Binary,
  Cw20ReceiveMsg,
  FeeResponse,
  AssetBaseForAddr,
  UncheckedEmissionType,
  InstantiateMsg,
  AddOnInstantiateMsg,
  ContributionInstantiateMsg,
  SubscriptionInstantiateMsg,
  QueryMsg,
  AddOnQueryMsg,
  StateResponse,
  ContributionState,
  SubscriptionState,
  SubscriberStateResponse,
  Subscriber,
} from './Subscription.types'
import { SubscriptionQueryClient, SubscriptionClient } from './Subscription.client'
export const subscriptionQueryKeys = {
  contract: [
    {
      contract: 'subscription',
    },
  ] as const,
  address: (contractAddress: string | undefined) =>
    [{ ...subscriptionQueryKeys.contract[0], address: contractAddress }] as const,
  base: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...subscriptionQueryKeys.address(contractAddress)[0], method: 'base', args }] as const,
  state: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...subscriptionQueryKeys.address(contractAddress)[0], method: 'state', args }] as const,
  config: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...subscriptionQueryKeys.address(contractAddress)[0], method: 'config', args }] as const,
  fee: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...subscriptionQueryKeys.address(contractAddress)[0], method: 'fee', args }] as const,
  subscriberState: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [
      { ...subscriptionQueryKeys.address(contractAddress)[0], method: 'subscriber_state', args },
    ] as const,
  contributorState: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [
      { ...subscriptionQueryKeys.address(contractAddress)[0], method: 'contributor_state', args },
    ] as const,
}
export interface SubscriptionReactQuery<TResponse, TData = TResponse> {
  client: SubscriptionQueryClient | undefined
  options?: Omit<
    UseQueryOptions<TResponse, Error, TData>,
    "'queryKey' | 'queryFn' | 'initialData'"
  > & {
    initialData?: undefined
  }
}
export interface SubscriptionContributorStateQuery<TData>
  extends SubscriptionReactQuery<ContributorStateResponse, TData> {
  args: {
    osId: number
  }
}
export function useSubscriptionContributorStateQuery<TData = ContributorStateResponse>({
  client,
  args,
  options,
}: SubscriptionContributorStateQuery<TData>) {
  return useQuery<ContributorStateResponse, Error, TData>(
    subscriptionQueryKeys.contributorState(client?.contractAddress, args),
    () =>
      client
        ? client.contributorState({
            osId: args.osId,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface SubscriptionSubscriberStateQuery<TData>
  extends SubscriptionReactQuery<SubscriberStateResponse, TData> {
  args: {
    osId: number
  }
}
export function useSubscriptionSubscriberStateQuery<TData = SubscriberStateResponse>({
  client,
  args,
  options,
}: SubscriptionSubscriberStateQuery<TData>) {
  return useQuery<SubscriberStateResponse, Error, TData>(
    subscriptionQueryKeys.subscriberState(client?.contractAddress, args),
    () =>
      client
        ? client.subscriberState({
            osId: args.osId,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface SubscriptionFeeQuery<TData> extends SubscriptionReactQuery<FeeResponse, TData> {}
export function useSubscriptionFeeQuery<TData = FeeResponse>({
  client,
  options,
}: SubscriptionFeeQuery<TData>) {
  return useQuery<FeeResponse, Error, TData>(
    subscriptionQueryKeys.fee(client?.contractAddress),
    () => (client ? client.fee() : Promise.reject(new Error('Invalid client'))),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface SubscriptionConfigQuery<TData>
  extends SubscriptionReactQuery<ConfigResponse, TData> {}
export function useSubscriptionConfigQuery<TData = ConfigResponse>({
  client,
  options,
}: SubscriptionConfigQuery<TData>) {
  return useQuery<ConfigResponse, Error, TData>(
    subscriptionQueryKeys.config(client?.contractAddress),
    () => (client ? client.config() : Promise.reject(new Error('Invalid client'))),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface SubscriptionStateQuery<TData>
  extends SubscriptionReactQuery<StateResponse, TData> {}
export function useSubscriptionStateQuery<TData = StateResponse>({
  client,
  options,
}: SubscriptionStateQuery<TData>) {
  return useQuery<StateResponse, Error, TData>(
    subscriptionQueryKeys.state(client?.contractAddress),
    () => (client ? client.state() : Promise.reject(new Error('Invalid client'))),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface SubscriptionBaseQuery<TData> extends SubscriptionReactQuery<BaseResponse, TData> {}
export function useSubscriptionBaseQuery<TData = BaseResponse>({
  client,
  options,
}: SubscriptionBaseQuery<TData>) {
  return useQuery<BaseResponse, Error, TData>(
    subscriptionQueryKeys.base(client?.contractAddress),
    () => (client ? client.queryBase() : Promise.reject(new Error('Invalid client'))),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface SubscriptionUpdateContributionConfigMutation {
  client: SubscriptionClient
  msg: {
    emissionUserShare?: Decimal
    emissionsAmpFactor?: Uint128
    emissionsOffset?: Uint128
    maxEmissionsMultiple?: Decimal
    projectTokenInfo?: AssetInfoBaseForString
    protocolIncomeShare?: Decimal
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useSubscriptionUpdateContributionConfigMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, SubscriptionUpdateContributionConfigMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, SubscriptionUpdateContributionConfigMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.updateContributionConfig(msg, fee, memo, funds),
    options
  )
}
export interface SubscriptionUpdateSubscriptionConfigMutation {
  client: SubscriptionClient
  msg: {
    factoryAddress?: string
    paymentAsset?: AssetInfoBaseForString
    subscriptionCost?: Decimal
    versionControlAddress?: string
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useSubscriptionUpdateSubscriptionConfigMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, SubscriptionUpdateSubscriptionConfigMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, SubscriptionUpdateSubscriptionConfigMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.updateSubscriptionConfig(msg, fee, memo, funds),
    options
  )
}
export interface SubscriptionRemoveContributorMutation {
  client: SubscriptionClient
  msg: {
    osId: number
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useSubscriptionRemoveContributorMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, SubscriptionRemoveContributorMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, SubscriptionRemoveContributorMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.removeContributor(msg, fee, memo, funds),
    options
  )
}
export interface SubscriptionUpdateContributorMutation {
  client: SubscriptionClient
  msg: {
    basePerBlock?: Decimal
    contributorOsId: number
    expirationBlock?: Uint64
    weight?: Uint64
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useSubscriptionUpdateContributorMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, SubscriptionUpdateContributorMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, SubscriptionUpdateContributorMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.updateContributor(msg, fee, memo, funds),
    options
  )
}
export interface SubscriptionClaimEmissionsMutation {
  client: SubscriptionClient
  msg: {
    osId: number
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useSubscriptionClaimEmissionsMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, SubscriptionClaimEmissionsMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, SubscriptionClaimEmissionsMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.claimEmissions(msg, fee, memo, funds),
    options
  )
}
export interface SubscriptionClaimCompensationMutation {
  client: SubscriptionClient
  msg: {
    osId: number
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useSubscriptionClaimCompensationMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, SubscriptionClaimCompensationMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, SubscriptionClaimCompensationMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.claimCompensation(msg, fee, memo, funds),
    options
  )
}
export interface SubscriptionUnsubscribeMutation {
  client: SubscriptionClient
  msg: {
    osIds: number[]
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useSubscriptionUnsubscribeMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, SubscriptionUnsubscribeMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, SubscriptionUnsubscribeMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) => client.unsubscribe(msg, fee, memo, funds),
    options
  )
}
export interface SubscriptionPayMutation {
  client: SubscriptionClient
  msg: {
    osId: number
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useSubscriptionPayMutation(
  options?: Omit<UseMutationOptions<ExecuteResult, Error, SubscriptionPayMutation>, 'mutationFn'>
) {
  return useMutation<ExecuteResult, Error, SubscriptionPayMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) => client.pay(msg, fee, memo, funds),
    options
  )
}
export interface SubscriptionReceiveMutation {
  client: SubscriptionClient
  msg: Cw20ReceiveMsg
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useSubscriptionReceiveMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, SubscriptionReceiveMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, SubscriptionReceiveMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) => client.receive(msg, fee, memo, funds),
    options
  )
}
export interface SubscriptionBaseMutation {
  client: SubscriptionClient
  msg: AddOnExecuteMsg
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useSubscriptionBaseMutation(
  options?: Omit<UseMutationOptions<ExecuteResult, Error, SubscriptionBaseMutation>, 'mutationFn'>
) {
  return useMutation<ExecuteResult, Error, SubscriptionBaseMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) => client.base(msg, fee, memo, funds),
    options
  )
}
