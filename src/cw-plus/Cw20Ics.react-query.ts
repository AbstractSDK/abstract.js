/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.14.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { AdminResponse, AllowedResponse, Amount, Uint128, ChannelResponse, Coin, Cw20Coin, ChannelInfo, IbcEndpoint, ConfigResponse, ExecuteMsg, Binary, Cw20ReceiveMsg, TransferMsg, AllowMsg, InitMsg, ListAllowedResponse, AllowedInfo, ListChannelsResponse, PortResponse, QueryMsg } from "./Cw20Ics.types";
import { Cw20IcsQueryClient, Cw20IcsClient } from "./Cw20Ics.client";
export const cw20IcsQueryKeys = {
  contract: ([{
    contract: "cw20Ics"
  }] as const),
  address: (contractAddress: string | undefined) => ([{ ...cw20IcsQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  port: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cw20IcsQueryKeys.address(contractAddress)[0],
    method: "port",
    args
  }] as const),
  listChannels: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cw20IcsQueryKeys.address(contractAddress)[0],
    method: "list_channels",
    args
  }] as const),
  channel: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cw20IcsQueryKeys.address(contractAddress)[0],
    method: "channel",
    args
  }] as const),
  config: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cw20IcsQueryKeys.address(contractAddress)[0],
    method: "config",
    args
  }] as const),
  admin: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cw20IcsQueryKeys.address(contractAddress)[0],
    method: "admin",
    args
  }] as const),
  allowed: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cw20IcsQueryKeys.address(contractAddress)[0],
    method: "allowed",
    args
  }] as const),
  listAllowed: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cw20IcsQueryKeys.address(contractAddress)[0],
    method: "list_allowed",
    args
  }] as const)
};
export interface Cw20IcsReactQuery<TResponse, TData = TResponse> {
  client: Cw20IcsQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface Cw20IcsListAllowedQuery<TData> extends Cw20IcsReactQuery<ListAllowedResponse, TData> {
  args: {
    limit?: number;
    startAfter?: string;
  };
}
export function useCw20IcsListAllowedQuery<TData = ListAllowedResponse>({
  client,
  args,
  options
}: Cw20IcsListAllowedQuery<TData>) {
  return useQuery<ListAllowedResponse, Error, TData>(cw20IcsQueryKeys.listAllowed(client?.contractAddress, args), () => client ? client.listAllowed({
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw20IcsAllowedQuery<TData> extends Cw20IcsReactQuery<AllowedResponse, TData> {
  args: {
    contract: string;
  };
}
export function useCw20IcsAllowedQuery<TData = AllowedResponse>({
  client,
  args,
  options
}: Cw20IcsAllowedQuery<TData>) {
  return useQuery<AllowedResponse, Error, TData>(cw20IcsQueryKeys.allowed(client?.contractAddress, args), () => client ? client.allowed({
    contract: args.contract
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw20IcsAdminQuery<TData> extends Cw20IcsReactQuery<AdminResponse, TData> {}
export function useCw20IcsAdminQuery<TData = AdminResponse>({
  client,
  options
}: Cw20IcsAdminQuery<TData>) {
  return useQuery<AdminResponse, Error, TData>(cw20IcsQueryKeys.admin(client?.contractAddress), () => client ? client.admin() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw20IcsConfigQuery<TData> extends Cw20IcsReactQuery<ConfigResponse, TData> {}
export function useCw20IcsConfigQuery<TData = ConfigResponse>({
  client,
  options
}: Cw20IcsConfigQuery<TData>) {
  return useQuery<ConfigResponse, Error, TData>(cw20IcsQueryKeys.config(client?.contractAddress), () => client ? client.config() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw20IcsChannelQuery<TData> extends Cw20IcsReactQuery<ChannelResponse, TData> {
  args: {
    id: string;
  };
}
export function useCw20IcsChannelQuery<TData = ChannelResponse>({
  client,
  args,
  options
}: Cw20IcsChannelQuery<TData>) {
  return useQuery<ChannelResponse, Error, TData>(cw20IcsQueryKeys.channel(client?.contractAddress, args), () => client ? client.channel({
    id: args.id
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw20IcsListChannelsQuery<TData> extends Cw20IcsReactQuery<ListChannelsResponse, TData> {}
export function useCw20IcsListChannelsQuery<TData = ListChannelsResponse>({
  client,
  options
}: Cw20IcsListChannelsQuery<TData>) {
  return useQuery<ListChannelsResponse, Error, TData>(cw20IcsQueryKeys.listChannels(client?.contractAddress), () => client ? client.listChannels() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw20IcsPortQuery<TData> extends Cw20IcsReactQuery<PortResponse, TData> {}
export function useCw20IcsPortQuery<TData = PortResponse>({
  client,
  options
}: Cw20IcsPortQuery<TData>) {
  return useQuery<PortResponse, Error, TData>(cw20IcsQueryKeys.port(client?.contractAddress), () => client ? client.port() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface Cw20IcsUpdateAdminMutation {
  client: Cw20IcsClient;
  msg: {
    admin: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCw20IcsUpdateAdminMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Cw20IcsUpdateAdminMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Cw20IcsUpdateAdminMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateAdmin(msg, fee, memo, funds), options);
}
export interface Cw20IcsAllowMutation {
  client: Cw20IcsClient;
  msg: AllowMsg;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCw20IcsAllowMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Cw20IcsAllowMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Cw20IcsAllowMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.allow(msg, fee, memo, funds), options);
}
export interface Cw20IcsTransferMutation {
  client: Cw20IcsClient;
  msg: TransferMsg;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCw20IcsTransferMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Cw20IcsTransferMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Cw20IcsTransferMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.transfer(msg, fee, memo, funds), options);
}
export interface Cw20IcsReceiveMutation {
  client: Cw20IcsClient;
  msg: Cw20ReceiveMsg;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCw20IcsReceiveMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, Cw20IcsReceiveMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, Cw20IcsReceiveMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.receive(msg, fee, memo, funds), options);
}