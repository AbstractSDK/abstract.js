/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.6.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { useQuery, UseQueryOptions, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { AssetInfoBaseForAddr, Addr, AssetEntry, CheckValidityResponse, ConfigResponse, CosmosMsgForEmpty, BankMsg, Uint128, StakingMsg, DistributionMsg, WasmMsg, Binary, Coin, Empty, ExecuteMsg, UncheckedValueRef, Decimal, UncheckedProxyAsset, HoldingAmountResponse, HoldingValueResponse, InstantiateMsg, ValueRef, ProxyAssetConfigResponse, ProxyAsset, ContractEntry, ProxyAssetsResponse, QueryMsg, State, TotalValueResponse } from "../contracts/ProxyContract";
import { ProxyQueryClient, ProxyClient } from "../contracts/ProxyContract";
export interface ProxyCheckValidityQuery {
  client?: ProxyQueryClient;
  options?: Omit<UseQueryOptions<CheckValidityResponse | undefined, Error, CheckValidityResponse, (string | undefined)[]>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export function useProxyCheckValidityQuery({
  client,
  options
}: ProxyCheckValidityQuery) {
  return useQuery<CheckValidityResponse | undefined, Error, CheckValidityResponse, (string | undefined)[]>(["proxyCheckValidity", client?.contractAddress], () => client ? client.checkValidity() : undefined, { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ProxyProxyAssetsQuery {
  client?: ProxyQueryClient;
  options?: Omit<UseQueryOptions<ProxyAssetsResponse | undefined, Error, ProxyAssetsResponse, (string | undefined)[]>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
  args: {
    iterLimit?: number;
    lastAssetName?: string;
  };
}
export function useProxyProxyAssetsQuery({
  client,
  args,
  options
}: ProxyProxyAssetsQuery) {
  return useQuery<ProxyAssetsResponse | undefined, Error, ProxyAssetsResponse, (string | undefined)[]>(["proxyProxyAssets", client?.contractAddress, JSON.stringify(args)], () => client ? client.proxyAssets({
    iterLimit: args.iterLimit,
    lastAssetName: args.lastAssetName
  }) : undefined, { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ProxyProxyAssetConfigQuery {
  client?: ProxyQueryClient;
  options?: Omit<UseQueryOptions<ProxyAssetConfigResponse | undefined, Error, ProxyAssetConfigResponse, (string | undefined)[]>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
  args: {
    identifier: string;
  };
}
export function useProxyProxyAssetConfigQuery({
  client,
  args,
  options
}: ProxyProxyAssetConfigQuery) {
  return useQuery<ProxyAssetConfigResponse | undefined, Error, ProxyAssetConfigResponse, (string | undefined)[]>(["proxyProxyAssetConfig", client?.contractAddress, JSON.stringify(args)], () => client ? client.proxyAssetConfig({
    identifier: args.identifier
  }) : undefined, { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ProxyHoldingAmountQuery {
  client?: ProxyQueryClient;
  options?: Omit<UseQueryOptions<HoldingAmountResponse | undefined, Error, HoldingAmountResponse, (string | undefined)[]>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
  args: {
    identifier: string;
  };
}
export function useProxyHoldingAmountQuery({
  client,
  args,
  options
}: ProxyHoldingAmountQuery) {
  return useQuery<HoldingAmountResponse | undefined, Error, HoldingAmountResponse, (string | undefined)[]>(["proxyHoldingAmount", client?.contractAddress, JSON.stringify(args)], () => client ? client.holdingAmount({
    identifier: args.identifier
  }) : undefined, { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ProxyHoldingValueQuery {
  client?: ProxyQueryClient;
  options?: Omit<UseQueryOptions<HoldingValueResponse | undefined, Error, HoldingValueResponse, (string | undefined)[]>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
  args: {
    identifier: string;
  };
}
export function useProxyHoldingValueQuery({
  client,
  args,
  options
}: ProxyHoldingValueQuery) {
  return useQuery<HoldingValueResponse | undefined, Error, HoldingValueResponse, (string | undefined)[]>(["proxyHoldingValue", client?.contractAddress, JSON.stringify(args)], () => client ? client.holdingValue({
    identifier: args.identifier
  }) : undefined, { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ProxyTotalValueQuery {
  client?: ProxyQueryClient;
  options?: Omit<UseQueryOptions<TotalValueResponse | undefined, Error, TotalValueResponse, (string | undefined)[]>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export function useProxyTotalValueQuery({
  client,
  options
}: ProxyTotalValueQuery) {
  return useQuery<TotalValueResponse | undefined, Error, TotalValueResponse, (string | undefined)[]>(["proxyTotalValue", client?.contractAddress], () => client ? client.totalValue() : undefined, { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ProxyConfigQuery {
  client?: ProxyQueryClient;
  options?: Omit<UseQueryOptions<ConfigResponse | undefined, Error, ConfigResponse, (string | undefined)[]>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export function useProxyConfigQuery({
  client,
  options
}: ProxyConfigQuery) {
  return useQuery<ConfigResponse | undefined, Error, ConfigResponse, (string | undefined)[]>(["proxyConfig", client?.contractAddress], () => client ? client.config() : undefined, { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ProxyUpdateAssetsMutation {
  client: ProxyClient;
  msg: {
    toAdd: UncheckedProxyAsset[];
    toRemove: string[];
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: readonly Coin[];
  };
}
export function useProxyUpdateAssetsMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, ProxyUpdateAssetsMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, ProxyUpdateAssetsMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateAssets(msg, fee, memo, funds), options);
}
export interface ProxyRemoveModuleMutation {
  client: ProxyClient;
  msg: {
    module: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: readonly Coin[];
  };
}
export function useProxyRemoveModuleMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, ProxyRemoveModuleMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, ProxyRemoveModuleMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.removeModule(msg, fee, memo, funds), options);
}
export interface ProxyAddModuleMutation {
  client: ProxyClient;
  msg: {
    module: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: readonly Coin[];
  };
}
export function useProxyAddModuleMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, ProxyAddModuleMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, ProxyAddModuleMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.addModule(msg, fee, memo, funds), options);
}
export interface ProxyModuleActionMutation {
  client: ProxyClient;
  msg: {
    msgs: CosmosMsgForEmpty[];
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: readonly Coin[];
  };
}
export function useProxyModuleActionMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, ProxyModuleActionMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, ProxyModuleActionMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.moduleAction(msg, fee, memo, funds), options);
}
export interface ProxySetAdminMutation {
  client: ProxyClient;
  msg: {
    admin: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: readonly Coin[];
  };
}
export function useProxySetAdminMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, ProxySetAdminMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, ProxySetAdminMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.setAdmin(msg, fee, memo, funds), options);
}
