/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.14.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { AssetEntry, AssetInfoBaseForAddr, Addr, AssetListResponse, AssetsResponse, ContractListResponse, ContractEntry, ContractsResponse, ExecuteMsg, AssetInfoBaseForString, UncheckedContractEntry, InstantiateMsg, QueryMsg } from "./Memory.types";
export interface MemoryReadOnlyInterface {
  contractAddress: string;
  assets: ({
    names
  }: {
    names: string[];
  }) => Promise<AssetsResponse>;
  contracts: ({
    names
  }: {
    names: ContractEntry[];
  }) => Promise<ContractsResponse>;
  contractList: ({
    pageSize,
    pageToken
  }: {
    pageSize?: number;
    pageToken?: ContractEntry;
  }) => Promise<ContractListResponse>;
  assetList: ({
    pageSize,
    pageToken
  }: {
    pageSize?: number;
    pageToken?: string;
  }) => Promise<AssetListResponse>;
}
export class MemoryQueryClient implements MemoryReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.assets = this.assets.bind(this);
    this.contracts = this.contracts.bind(this);
    this.contractList = this.contractList.bind(this);
    this.assetList = this.assetList.bind(this);
  }

  assets = async ({
    names
  }: {
    names: string[];
  }): Promise<AssetsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      assets: {
        names
      }
    });
  };
  contracts = async ({
    names
  }: {
    names: ContractEntry[];
  }): Promise<ContractsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      contracts: {
        names
      }
    });
  };
  contractList = async ({
    pageSize,
    pageToken
  }: {
    pageSize?: number;
    pageToken?: ContractEntry;
  }): Promise<ContractListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      contract_list: {
        page_size: pageSize,
        page_token: pageToken
      }
    });
  };
  assetList = async ({
    pageSize,
    pageToken
  }: {
    pageSize?: number;
    pageToken?: string;
  }): Promise<AssetListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      asset_list: {
        page_size: pageSize,
        page_token: pageToken
      }
    });
  };
}
export interface MemoryInterface extends MemoryReadOnlyInterface {
  contractAddress: string;
  sender: string;
  updateContractAddresses: ({
    toAdd,
    toRemove
  }: {
    toAdd: UncheckedContractEntry[][];
    toRemove: UncheckedContractEntry[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateAssetAddresses: ({
    toAdd,
    toRemove
  }: {
    toAdd: string[][];
    toRemove: string[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  setAdmin: ({
    admin
  }: {
    admin: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class MemoryClient extends MemoryQueryClient implements MemoryInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateContractAddresses = this.updateContractAddresses.bind(this);
    this.updateAssetAddresses = this.updateAssetAddresses.bind(this);
    this.setAdmin = this.setAdmin.bind(this);
  }

  updateContractAddresses = async ({
    toAdd,
    toRemove
  }: {
    toAdd: UncheckedContractEntry[][];
    toRemove: UncheckedContractEntry[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_contract_addresses: {
        to_add: toAdd,
        to_remove: toRemove
      }
    }, fee, memo, funds);
  };
  updateAssetAddresses = async ({
    toAdd,
    toRemove
  }: {
    toAdd: string[][];
    toRemove: string[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_asset_addresses: {
        to_add: toAdd,
        to_remove: toRemove
      }
    }, fee, memo, funds);
  };
  setAdmin = async ({
    admin
  }: {
    admin: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_admin: {
        admin
      }
    }, fee, memo, funds);
  };
}