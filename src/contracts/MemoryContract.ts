/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.5.8.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, ExecuteResult, SigningCosmWasmClient } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
export type AssetEntry = string;
export type AssetInfoBaseForAddr = {
  native: string;
} | {
  cw20: Addr;
} | {
  cw1155: [Addr, string];
};
export type Addr = string;
export interface AssetListResponse {
  assets: [AssetEntry, AssetInfoBaseForAddr][];
}
export interface AssetsResponse {
  assets: [AssetEntry, AssetInfoBaseForAddr][];
}
export interface ContractListResponse {
  contracts: [ContractEntry, string][];
}
export interface ContractEntry {
  contract: string;
  protocol: string;
}
export interface ContractsResponse {
  contracts: [ContractEntry, string][];
}
export interface InstantiateMsg {
}
export type QueryMsg = {
  assets: {
    names: string[];
  };
} | {
  contracts: {
    names: ContractEntry[];
  };
} | {
  contract_list: {
    iter_limit?: number | null;
    last_contract?: ContractEntry | null;
  };
} | {
  asset_list: {
    iter_limit?: number | null;
    last_asset_name?: string | null;
  };
};
export interface MemoryReadOnlyInterface {
  contractAddress: string;
  assets: ({
    names
  }: {
    names: string[];
  }) => Promise<AssetsResponse>;
  contracts: ({
    names
  }: {
    names: ContractEntry[];
  }) => Promise<ContractsResponse>;
  contractList: ({
    iterLimit,
    lastContract
  }: {
    iterLimit?: number;
    lastContract?: ContractEntry;
  }) => Promise<ContractListResponse>;
  assetList: ({
    iterLimit,
    lastAssetName
  }: {
    iterLimit?: number;
    lastAssetName?: string;
  }) => Promise<AssetListResponse>;
}
export class MemoryQueryClient implements MemoryReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.assets = this.assets.bind(this);
    this.contracts = this.contracts.bind(this);
    this.contractList = this.contractList.bind(this);
    this.assetList = this.assetList.bind(this);
  }

  assets = async ({
    names
  }: {
    names: string[];
  }): Promise<AssetsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      assets: {
        names
      }
    });
  };
  contracts = async ({
    names
  }: {
    names: ContractEntry[];
  }): Promise<ContractsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      contracts: {
        names
      }
    });
  };
  contractList = async ({
    iterLimit,
    lastContract
  }: {
    iterLimit?: number;
    lastContract?: ContractEntry;
  }): Promise<ContractListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      contract_list: {
        iter_limit: iterLimit,
        last_contract: lastContract
      }
    });
  };
  assetList = async ({
    iterLimit,
    lastAssetName
  }: {
    iterLimit?: number;
    lastAssetName?: string;
  }): Promise<AssetListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      asset_list: {
        iter_limit: iterLimit,
        last_asset_name: lastAssetName
      }
    });
  };
}