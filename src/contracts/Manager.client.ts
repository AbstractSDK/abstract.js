/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.10.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Binary, Uint64, ConfigResponse, ExecuteMsg, ModuleKind, Module, ModuleInfo, InfoResponse, OsInfo, InstantiateMsg, ManagerModuleInfo, ContractVersion, ModuleAddressesResponse, ModuleInfosResponse, ModuleVersionsResponse, QueryMsg, QueryOsConfigResponse } from "../types/Manager.types";
export interface ManagerReadOnlyInterface {
  contractAddress: string;
  moduleVersions: ({
    names
  }: {
    names: string[];
  }) => Promise<ModuleVersionsResponse>;
  moduleAddresses: ({
    names
  }: {
    names: string[];
  }) => Promise<ModuleAddressesResponse>;
  moduleInfos: ({
    iterLimit,
    lastModuleName
  }: {
    iterLimit?: number;
    lastModuleName?: string;
  }) => Promise<ModuleInfosResponse>;
  config: () => Promise<ConfigResponse>;
  info: () => Promise<InfoResponse>;
}
export class ManagerQueryClient implements ManagerReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.moduleVersions = this.moduleVersions.bind(this);
    this.moduleAddresses = this.moduleAddresses.bind(this);
    this.moduleInfos = this.moduleInfos.bind(this);
    this.config = this.config.bind(this);
    this.info = this.info.bind(this);
  }

  moduleVersions = async ({
    names
  }: {
    names: string[];
  }): Promise<ModuleVersionsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      module_versions: {
        names
      }
    });
  };
  moduleAddresses = async ({
    names
  }: {
    names: string[];
  }): Promise<ModuleAddressesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      module_addresses: {
        names
      }
    });
  };
  moduleInfos = async ({
    iterLimit,
    lastModuleName
  }: {
    iterLimit?: number;
    lastModuleName?: string;
  }): Promise<ModuleInfosResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      module_infos: {
        iter_limit: iterLimit,
        last_module_name: lastModuleName
      }
    });
  };
  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  info = async (): Promise<InfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      info: {}
    });
  };
}
export interface ManagerInterface extends ManagerReadOnlyInterface {
  contractAddress: string;
  sender: string;
  setAdmin: ({
    admin,
    governanceType
  }: {
    admin: string;
    governanceType?: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  createModule: ({
    initMsg,
    module
  }: {
    initMsg?: Binary;
    module: Module;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  registerModule: ({
    module,
    moduleAddr
  }: {
    module: Module;
    moduleAddr: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  removeModule: ({
    moduleName
  }: {
    moduleName: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  execOnModule: ({
    execMsg,
    moduleName
  }: {
    execMsg: Binary;
    moduleName: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateConfig: ({
    root,
    vcAddr
  }: {
    root?: string;
    vcAddr?: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  upgrade: ({
    migrateMsg,
    module
  }: {
    migrateMsg?: Binary;
    module: Module;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  suspendOs: ({
    newStatus
  }: {
    newStatus: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateInfo: ({
    description,
    link,
    name
  }: {
    description?: string;
    link?: string;
    name?: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class ManagerClient extends ManagerQueryClient implements ManagerInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.setAdmin = this.setAdmin.bind(this);
    this.createModule = this.createModule.bind(this);
    this.registerModule = this.registerModule.bind(this);
    this.removeModule = this.removeModule.bind(this);
    this.execOnModule = this.execOnModule.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
    this.upgrade = this.upgrade.bind(this);
    this.suspendOs = this.suspendOs.bind(this);
    this.updateInfo = this.updateInfo.bind(this);
  }

  setAdmin = async ({
    admin,
    governanceType
  }: {
    admin: string;
    governanceType?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_admin: {
        admin,
        governance_type: governanceType
      }
    }, fee, memo, funds);
  };
  createModule = async ({
    initMsg,
    module
  }: {
    initMsg?: Binary;
    module: Module;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_module: {
        init_msg: initMsg,
        module
      }
    }, fee, memo, funds);
  };
  registerModule = async ({
    module,
    moduleAddr
  }: {
    module: Module;
    moduleAddr: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      register_module: {
        module,
        module_addr: moduleAddr
      }
    }, fee, memo, funds);
  };
  removeModule = async ({
    moduleName
  }: {
    moduleName: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_module: {
        module_name: moduleName
      }
    }, fee, memo, funds);
  };
  execOnModule = async ({
    execMsg,
    moduleName
  }: {
    execMsg: Binary;
    moduleName: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      exec_on_module: {
        exec_msg: execMsg,
        module_name: moduleName
      }
    }, fee, memo, funds);
  };
  updateConfig = async ({
    root,
    vcAddr
  }: {
    root?: string;
    vcAddr?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        root,
        vc_addr: vcAddr
      }
    }, fee, memo, funds);
  };
  upgrade = async ({
    migrateMsg,
    module
  }: {
    migrateMsg?: Binary;
    module: Module;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      upgrade: {
        migrate_msg: migrateMsg,
        module
      }
    }, fee, memo, funds);
  };
  suspendOs = async ({
    newStatus
  }: {
    newStatus: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      suspend_os: {
        new_status: newStatus
      }
    }, fee, memo, funds);
  };
  updateInfo = async ({
    description,
    link,
    name
  }: {
    description?: string;
    link?: string;
    name?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_info: {
        description,
        link,
        name
      }
    }, fee, memo, funds);
  };
}
