/**
* This file was automatically generated by cosmwasm-typescript-gen@0.2.15.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the cosmwasm-typescript-gen generate command to regenerate this file.
*/

import { CosmWasmClient, ExecuteResult, SigningCosmWasmClient } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
export type Binary = string;
export interface InstantiateMsg {
  chain_id: string;
  description?: string | null;
  governance_type: string;
  link?: string | null;
  module_factory_address: string;
  os_id: number;
  os_name: string;
  root_user: string;
  subscription_address?: string | null;
  version_control_address: string;
  [k: string]: unknown;
}
export interface ManagerModuleInfo {
  address: string;
  name: string;
  version: ContractVersion;
  [k: string]: unknown;
}
export interface ContractVersion {
  contract: string;
  version: string;
  [k: string]: unknown;
}
export type ModuleKind = "add_on" | "a_p_i" | "service" | "perk";
export interface Module {
  info: ModuleInfo;
  kind: ModuleKind;
  [k: string]: unknown;
}
export interface ModuleInfo {
  name: string;
  version?: string | null;
  [k: string]: unknown;
}
export interface OsInfo {
  chain_id: string;
  description?: string | null;
  governance_type: string;
  link?: string | null;
  name: string;
  [k: string]: unknown;
}
export type Uint64 = string;
export interface QueryConfigResponse {
  module_factory_address: string;
  os_id: Uint64;
  root: string;
  version_control_address: string;
  [k: string]: unknown;
}
export interface QueryInfoResponse {
  info: OsInfo;
  [k: string]: unknown;
}
export interface QueryModuleAddressesResponse {
  modules: [string, string][];
  [k: string]: unknown;
}
export interface QueryModuleInfosResponse {
  module_infos: ManagerModuleInfo[];
  [k: string]: unknown;
}
export interface QueryModuleVersionsResponse {
  versions: ContractVersion[];
  [k: string]: unknown;
}
export interface ManagerReadOnlyInterface {
  contractAddress: string;
  queryModuleVersions: ({
    names
  }: {
    names: string[];
  }) => Promise<QueryModuleVersionsResponse>;
  queryModuleAddresses: ({
    names
  }: {
    names: string[];
  }) => Promise<QueryModuleAddressesResponse>;
  queryModuleInfos: ({
    iterLimit,
    lastModuleName
  }: {
    iterLimit?: number;
    lastModuleName?: string;
  }) => Promise<QueryModuleInfosResponse>;
  queryConfig: () => Promise<QueryConfigResponse>;
  queryInfo: () => Promise<QueryInfoResponse>;
}
export class ManagerQueryClient implements ManagerReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.queryModuleVersions = this.queryModuleVersions.bind(this);
    this.queryModuleAddresses = this.queryModuleAddresses.bind(this);
    this.queryModuleInfos = this.queryModuleInfos.bind(this);
    this.queryConfig = this.queryConfig.bind(this);
    this.queryInfo = this.queryInfo.bind(this);
  }

  queryModuleVersions = async ({
    names
  }: {
    names: string[];
  }): Promise<QueryModuleVersionsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_module_versions: {
        names
      }
    });
  };
  queryModuleAddresses = async ({
    names
  }: {
    names: string[];
  }): Promise<QueryModuleAddressesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_module_addresses: {
        names
      }
    });
  };
  queryModuleInfos = async ({
    iterLimit,
    lastModuleName
  }: {
    iterLimit?: number;
    lastModuleName?: string;
  }): Promise<QueryModuleInfosResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_module_infos: {
        iter_limit: iterLimit,
        last_module_name: lastModuleName
      }
    });
  };
  queryConfig = async (): Promise<QueryConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_config: {}
    });
  };
  queryInfo = async (): Promise<QueryInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_info: {}
    });
  };
}
export interface ManagerInterface extends ManagerReadOnlyInterface {
  contractAddress: string;
  sender: string;
  setAdmin: ({
    admin,
    governanceType
  }: {
    admin: string;
    governanceType?: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  createModule: ({
    initMsg,
    module
  }: {
    initMsg?: Binary;
    module: Module;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  registerModule: ({
    module,
    moduleAddr
  }: {
    module: Module;
    moduleAddr: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  removeModule: ({
    moduleName
  }: {
    moduleName: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  execOnModule: ({
    execMsg,
    moduleName
  }: {
    execMsg: Binary;
    moduleName: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  updateConfig: ({
    root,
    vcAddr
  }: {
    root?: string;
    vcAddr?: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  upgrade: ({
    migrateMsg,
    module
  }: {
    migrateMsg?: Binary;
    module: Module;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  suspendOs: ({
    newStatus
  }: {
    newStatus: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  updateInfo: ({
    description,
    link,
    osName
  }: {
    description?: string;
    link?: string;
    osName?: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
}
export class ManagerClient extends ManagerQueryClient implements ManagerInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.setAdmin = this.setAdmin.bind(this);
    this.createModule = this.createModule.bind(this);
    this.registerModule = this.registerModule.bind(this);
    this.removeModule = this.removeModule.bind(this);
    this.execOnModule = this.execOnModule.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
    this.upgrade = this.upgrade.bind(this);
    this.suspendOs = this.suspendOs.bind(this);
    this.updateInfo = this.updateInfo.bind(this);
  }

  setAdmin = async ({
    admin,
    governanceType
  }: {
    admin: string;
    governanceType?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_admin: {
        admin,
        governance_type: governanceType
      }
    }, fee, memo, funds);
  };
  createModule = async ({
    initMsg,
    module
  }: {
    initMsg?: Binary;
    module: Module;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_module: {
        init_msg: initMsg,
        module
      }
    }, fee, memo, funds);
  };
  registerModule = async ({
    module,
    moduleAddr
  }: {
    module: Module;
    moduleAddr: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      register_module: {
        module,
        module_addr: moduleAddr
      }
    }, fee, memo, funds);
  };
  removeModule = async ({
    moduleName
  }: {
    moduleName: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_module: {
        module_name: moduleName
      }
    }, fee, memo, funds);
  };
  execOnModule = async ({
    execMsg,
    moduleName
  }: {
    execMsg: Binary;
    moduleName: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      exec_on_module: {
        exec_msg: execMsg,
        module_name: moduleName
      }
    }, fee, memo, funds);
  };
  updateConfig = async ({
    root,
    vcAddr
  }: {
    root?: string;
    vcAddr?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        root,
        vc_addr: vcAddr
      }
    }, fee, memo, funds);
  };
  upgrade = async ({
    migrateMsg,
    module
  }: {
    migrateMsg?: Binary;
    module: Module;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      upgrade: {
        migrate_msg: migrateMsg,
        module
      }
    }, fee, memo, funds);
  };
  suspendOs = async ({
    newStatus
  }: {
    newStatus: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      suspend_os: {
        new_status: newStatus
      }
    }, fee, memo, funds);
  };
  updateInfo = async ({
    description,
    link,
    osName
  }: {
    description?: string;
    link?: string;
    osName?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_info: {
        description,
        link,
        os_name: osName
      }
    }, fee, memo, funds);
  };
}