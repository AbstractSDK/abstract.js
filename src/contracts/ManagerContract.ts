/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.6.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, ExecuteResult, SigningCosmWasmClient } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
export type Binary = string;
export type Uint64 = string;
export interface ConfigResponse {
  module_factory_address: string;
  os_id: Uint64;
  root: string;
  version_control_address: string;
}
export type ExecuteMsg = {
  set_admin: {
    admin: string;
    governance_type?: string | null;
  };
} | {
  create_module: {
    init_msg?: Binary | null;
    module: Module;
  };
} | {
  register_module: {
    module: Module;
    module_addr: string;
  };
} | {
  remove_module: {
    module_name: string;
  };
} | {
  exec_on_module: {
    exec_msg: Binary;
    module_name: string;
  };
} | {
  update_config: {
    root?: string | null;
    vc_addr?: string | null;
  };
} | {
  upgrade: {
    migrate_msg?: Binary | null;
    module: Module;
  };
} | {
  suspend_os: {
    new_status: boolean;
  };
} | {
  update_info: {
    description?: string | null;
    link?: string | null;
    name?: string | null;
  };
};
export type ModuleKind = "add_on" | "a_p_i" | "service" | "perk";
export interface Module {
  info: ModuleInfo;
  kind: ModuleKind;
}
export interface ModuleInfo {
  name: string;
  version?: string | null;
}
export interface InfoResponse {
  info: OsInfo;
}
export interface OsInfo {
  chain_id: string;
  description?: string | null;
  governance_type: string;
  link?: string | null;
  name: string;
}
export interface InstantiateMsg {
  description?: string | null;
  governance_type: string;
  link?: string | null;
  module_factory_address: string;
  name: string;
  os_id: number;
  root_user: string;
  subscription_address?: string | null;
  version_control_address: string;
}
export interface ManagerModuleInfo {
  address: string;
  name: string;
  version: ContractVersion;
}
export interface ContractVersion {
  contract: string;
  version: string;
}
export interface ModuleAddressesResponse {
  modules: [string, string][];
}
export interface ModuleInfosResponse {
  module_infos: ManagerModuleInfo[];
}
export interface ModuleVersionsResponse {
  versions: ContractVersion[];
}
export type QueryMsg = {
  module_versions: {
    names: string[];
  };
} | {
  module_addresses: {
    names: string[];
  };
} | {
  module_infos: {
    iter_limit?: number | null;
    last_module_name?: string | null;
  };
} | {
  config: {
  };
} | {
  info: {
  };
};
export interface QueryOsConfigResponse {
  module_factory_address: string;
  os_id: Uint64;
  root: string;
  version_control_address: string;
}
export type ManagerExecuteMsg = ExecuteMsg;
export interface ManagerReadOnlyInterface {
  contractAddress: string;
  moduleVersions: ({
    names
  }: {
    names: string[];
  }) => Promise<ModuleVersionsResponse>;
  moduleAddresses: ({
    names
  }: {
    names: string[];
  }) => Promise<ModuleAddressesResponse>;
  moduleInfos: ({
    iterLimit,
    lastModuleName
  }: {
    iterLimit?: number;
    lastModuleName?: string;
  }) => Promise<ModuleInfosResponse>;
  config: () => Promise<ConfigResponse>;
  info: () => Promise<InfoResponse>;
}
export class ManagerQueryClient implements ManagerReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.moduleVersions = this.moduleVersions.bind(this);
    this.moduleAddresses = this.moduleAddresses.bind(this);
    this.moduleInfos = this.moduleInfos.bind(this);
    this.config = this.config.bind(this);
    this.info = this.info.bind(this);
  }

  moduleVersions = async ({
    names
  }: {
    names: string[];
  }): Promise<ModuleVersionsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      module_versions: {
        names
      }
    });
  };
  moduleAddresses = async ({
    names
  }: {
    names: string[];
  }): Promise<ModuleAddressesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      module_addresses: {
        names
      }
    });
  };
  moduleInfos = async ({
    iterLimit,
    lastModuleName
  }: {
    iterLimit?: number;
    lastModuleName?: string;
  }): Promise<ModuleInfosResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      module_infos: {
        iter_limit: iterLimit,
        last_module_name: lastModuleName
      }
    });
  };
  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  info = async (): Promise<InfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      info: {}
    });
  };
}
export interface ManagerInterface extends ManagerReadOnlyInterface {
  contractAddress: string;
  sender: string;
  setAdmin: ({
    admin,
    governanceType
  }: {
    admin: string;
    governanceType?: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  createModule: ({
    initMsg,
    module
  }: {
    initMsg?: Binary;
    module: Module;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  registerModule: ({
    module,
    moduleAddr
  }: {
    module: Module;
    moduleAddr: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  removeModule: ({
    moduleName
  }: {
    moduleName: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  execOnModule: ({
    execMsg,
    moduleName
  }: {
    execMsg: string;
    moduleName: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  updateConfig: ({
    root,
    vcAddr
  }: {
    root?: string;
    vcAddr?: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  upgrade: ({
    migrateMsg,
    module
  }: {
    migrateMsg?: Binary;
    module: Module;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  suspendOs: ({
    newStatus
  }: {
    newStatus: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  updateInfo: ({
    description,
    link,
    name
  }: {
    description?: string;
    link?: string;
    name?: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
}
export class ManagerClient extends ManagerQueryClient implements ManagerInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.setAdmin = this.setAdmin.bind(this);
    this.createModule = this.createModule.bind(this);
    this.registerModule = this.registerModule.bind(this);
    this.removeModule = this.removeModule.bind(this);
    this.execOnModule = this.execOnModule.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
    this.upgrade = this.upgrade.bind(this);
    this.suspendOs = this.suspendOs.bind(this);
    this.updateInfo = this.updateInfo.bind(this);
  }

  setAdmin = async ({
    admin,
    governanceType
  }: {
    admin: string;
    governanceType?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_admin: {
        admin,
        governance_type: governanceType
      }
    }, fee, memo, funds);
  };
  createModule = async ({
    initMsg,
    module
  }: {
    initMsg?: Binary;
    module: Module;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_module: {
        init_msg: initMsg,
        module
      }
    }, fee, memo, funds);
  };
  registerModule = async ({
    module,
    moduleAddr
  }: {
    module: Module;
    moduleAddr: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      register_module: {
        module,
        module_addr: moduleAddr
      }
    }, fee, memo, funds);
  };
  removeModule = async ({
    moduleName
  }: {
    moduleName: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_module: {
        module_name: moduleName
      }
    }, fee, memo, funds);
  };
  execOnModule = async ({
    execMsg,
    moduleName
  }: {
    execMsg: string;
    moduleName: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      exec_on_module: {
        exec_msg: execMsg,
        module_name: moduleName
      }
    }, fee, memo, funds);
  };
  updateConfig = async ({
    root,
    vcAddr
  }: {
    root?: string;
    vcAddr?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        root,
        vc_addr: vcAddr
      }
    }, fee, memo, funds);
  };
  upgrade = async ({
    migrateMsg,
    module
  }: {
    migrateMsg?: Binary;
    module: Module;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      upgrade: {
        migrate_msg: migrateMsg,
        module
      }
    }, fee, memo, funds);
  };
  suspendOs = async ({
    newStatus
  }: {
    newStatus: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      suspend_os: {
        new_status: newStatus
      }
    }, fee, memo, funds);
  };
  updateInfo = async ({
    description,
    link,
    name
  }: {
    description?: string;
    link?: string;
    name?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_info: {
        description,
        link,
        name
      }
    }, fee, memo, funds);
  };
}