/**
 * This file was automatically generated by cosmwasm-typescript-gen@0.3.9.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the cosmwasm-typescript-gen generate command to regenerate this file.
 */

import { CosmWasmClient, ExecuteResult, SigningCosmWasmClient } from '@cosmjs/cosmwasm-stargate'
import { Coin, StdFee } from '@cosmjs/amino'
export type Addr = string
export interface AddOnState {
  memory: Memory
  proxy_address: Addr
}
export interface Memory {
  address: Addr
}
export type AssetInfoBaseFor_Addr =
  | {
      cw20: Addr
    }
  | {
      native: string
    }
export type AssetInfoBaseFor_String =
  | {
      cw20: string
    }
  | {
      native: string
    }
export type BaseResponse =
  | {
      config: {}
    }
  | {
      admin: {}
    }
export type Decimal = string
export type Uint128 = string
export type EmissionType =
  | 'None'
  | {
      BlockShared: [Decimal, AssetInfoBaseFor_Addr]
    }
  | {
      BlockPerUser: [Decimal, AssetInfoBaseFor_Addr]
    }
  | {
      IncomeBased: AssetInfoBaseFor_Addr
    }
export interface ConfigResponse {
  contribution: ContributionConfig
  subscription: SubscriptionConfig
}
export interface ContributionConfig {
  emission_user_share: Decimal
  emissions_amp_factor: Uint128
  emissions_offset: Uint128
  max_emissions_multiple: Decimal
  protocol_income_share: Decimal
  token_info: AssetInfoBaseFor_Addr
}
export interface SubscriptionConfig {
  factory_address: Addr
  payment_asset: AssetInfoBaseFor_Addr
  subscription_cost_per_block: Decimal
  subscription_per_block_emissions: EmissionType
  version_control_address: Addr
}
export type Uint64 = string
export interface ContributorStateResponse {
  compensation: Compensation
}
export interface Compensation {
  base_per_block: Decimal
  expiration_block: Uint64
  last_claim_block: Uint64
  weight: number
}
export type ExecuteMsg =
  | {
      base: AddOnExecuteMsg
    }
  | {
      receive: Cw20ReceiveMsg
    }
  | {
      pay: {
        os_id: number
      }
    }
  | {
      unsubscribe: {
        os_ids: number[]
      }
    }
  | {
      claim_compensation: {
        os_id: number
      }
    }
  | {
      claim_emissions: {
        os_id: number
      }
    }
  | {
      update_contributor: {
        base_per_block?: Decimal | null
        contributor_os_id: number
        expiration_block?: Uint64 | null
        weight?: Uint64 | null
      }
    }
  | {
      remove_contributor: {
        os_id: number
      }
    }
  | {
      update_subscription_config: {
        factory_address?: string | null
        payment_asset?: AssetInfoBaseFor_String | null
        subscription_cost?: Decimal | null
        version_control_address?: string | null
      }
    }
  | {
      update_contribution_config: {
        emission_user_share?: Decimal | null
        emissions_amp_factor?: Uint128 | null
        emissions_offset?: Uint128 | null
        max_emissions_multiple?: Decimal | null
        project_token_info?: AssetInfoBaseFor_String | null
        protocol_income_share?: Decimal | null
      }
    }
export type AddOnExecuteMsg = {
  update_config: {
    memory_address?: string | null
  }
}
export type Binary = string
export interface Cw20ReceiveMsg {
  amount: Uint128
  msg: Binary
  sender: string
}
export interface FeeResponse {
  fee: Asset
}
export interface Asset {
  amount: Uint128
  info: AssetInfoBaseFor_Addr
}
export type UncheckedEmissionType =
  | 'None'
  | {
      BlockShared: [Decimal, AssetInfoBaseFor_String]
    }
  | {
      BlockPerUser: [Decimal, AssetInfoBaseFor_String]
    }
  | {
      IncomeBased: AssetInfoBaseFor_String
    }
export interface InstantiateMsg {
  base: AddOnInstantiateMsg
  contribution?: ContributionInstantiateMsg | null
  subscription: SubscriptionInstantiateMsg
}
export interface AddOnInstantiateMsg {
  memory_address: string
}
export interface ContributionInstantiateMsg {
  emission_user_share: Decimal
  emissions_amp_factor: Uint128
  emissions_offset: Uint128
  income_averaging_period: Uint64
  max_emissions_multiple: Decimal
  protocol_income_share: Decimal
  token_info: AssetInfoBaseFor_String
}
export interface SubscriptionInstantiateMsg {
  factory_addr: string
  payment_asset: AssetInfoBaseFor_String
  subscription_cost_per_block: Decimal
  subscription_per_block_emissions: UncheckedEmissionType
  version_control_addr: string
}
export type QueryMsg =
  | {
      base: AddOnQueryMsg
    }
  | {
      state: {}
    }
  | {
      config: {}
    }
  | {
      fee: {}
    }
  | {
      subscriber_state: {
        os_id: number
      }
    }
  | {
      contributor_state: {
        os_id: number
      }
    }
export type AddOnQueryMsg =
  | {
      config: {}
    }
  | {
      admin: {}
    }
export interface StateResponse {
  contribution: ContributionState
  subscription: SubscriptionState
}
export interface ContributionState {
  emissions: Decimal
  expense: Decimal
  income_target: Decimal
  total_weight: Uint128
}
export interface SubscriptionState {
  active_subs: number
}
export interface SubscriberStateResponse {
  currently_subscribed: boolean
  subscriber_details: Subscriber
}
export interface Subscriber {
  expiration_block: number
  last_emission_claim_block: number
  manager_addr: Addr
}
export interface SubscriptionReadOnlyInterface {
  contractAddress: string
  queryBase: () => Promise<BaseResponse>
  state: () => Promise<StateResponse>
  config: () => Promise<ConfigResponse>
  fee: () => Promise<FeeResponse>
  subscriberState: ({ osId }: { osId: number }) => Promise<SubscriberStateResponse>
  contributorState: ({ osId }: { osId: number }) => Promise<ContributorStateResponse>
}
export class SubscriptionQueryClient implements SubscriptionReadOnlyInterface {
  client: CosmWasmClient
  contractAddress: string

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client
    this.contractAddress = contractAddress
    this.queryBase = this.queryBase.bind(this)
    this.state = this.state.bind(this)
    this.config = this.config.bind(this)
    this.fee = this.fee.bind(this)
    this.subscriberState = this.subscriberState.bind(this)
    this.contributorState = this.contributorState.bind(this)
  }

  queryBase = async (): Promise<BaseResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      base: {},
    })
  }
  state = async (): Promise<StateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      state: {},
    })
  }
  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {},
    })
  }
  fee = async (): Promise<FeeResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      fee: {},
    })
  }
  subscriberState = async ({ osId }: { osId: number }): Promise<SubscriberStateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      subscriber_state: {
        os_id: osId,
      },
    })
  }
  contributorState = async ({ osId }: { osId: number }): Promise<ContributorStateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      contributor_state: {
        os_id: osId,
      },
    })
  }
}
export interface SubscriptionInterface extends SubscriptionReadOnlyInterface {
  contractAddress: string
  sender: string
  base: (
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ) => Promise<ExecuteResult>
  receive: (
    {
      amount,
      msg,
      sender,
    }: {
      amount: string
      msg: string
      sender: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ) => Promise<ExecuteResult>
  pay: (
    {
      osId,
    }: {
      osId: number
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ) => Promise<ExecuteResult>
  unsubscribe: (
    {
      osIds,
    }: {
      osIds: number[]
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ) => Promise<ExecuteResult>
  claimCompensation: (
    {
      osId,
    }: {
      osId: number
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ) => Promise<ExecuteResult>
  claimEmissions: (
    {
      osId,
    }: {
      osId: number
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ) => Promise<ExecuteResult>
  updateContributor: (
    {
      basePerBlock,
      contributorOsId,
      expirationBlock,
      weight,
    }: {
      basePerBlock?: Decimal
      contributorOsId: number
      expirationBlock?: Uint64
      weight?: Uint64
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ) => Promise<ExecuteResult>
  removeContributor: (
    {
      osId,
    }: {
      osId: number
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ) => Promise<ExecuteResult>
  updateSubscriptionConfig: (
    {
      factoryAddress,
      paymentAsset,
      subscriptionCost,
      versionControlAddress,
    }: {
      factoryAddress?: string
      paymentAsset?: AssetInfoBaseFor_String
      subscriptionCost?: Decimal
      versionControlAddress?: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ) => Promise<ExecuteResult>
  updateContributionConfig: (
    {
      emissionUserShare,
      emissionsAmpFactor,
      emissionsOffset,
      maxEmissionsMultiple,
      projectTokenInfo,
      protocolIncomeShare,
    }: {
      emissionUserShare?: Decimal
      emissionsAmpFactor?: Uint128
      emissionsOffset?: Uint128
      maxEmissionsMultiple?: Decimal
      projectTokenInfo?: AssetInfoBaseFor_String
      protocolIncomeShare?: Decimal
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ) => Promise<ExecuteResult>
}
export class SubscriptionClient extends SubscriptionQueryClient implements SubscriptionInterface {
  client: SigningCosmWasmClient
  sender: string
  contractAddress: string

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress)
    this.client = client
    this.sender = sender
    this.contractAddress = contractAddress
    this.base = this.base.bind(this)
    this.receive = this.receive.bind(this)
    this.pay = this.pay.bind(this)
    this.unsubscribe = this.unsubscribe.bind(this)
    this.claimCompensation = this.claimCompensation.bind(this)
    this.claimEmissions = this.claimEmissions.bind(this)
    this.updateContributor = this.updateContributor.bind(this)
    this.removeContributor = this.removeContributor.bind(this)
    this.updateSubscriptionConfig = this.updateSubscriptionConfig.bind(this)
    this.updateContributionConfig = this.updateContributionConfig.bind(this)
  }

  base = async (
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        base: {},
      },
      fee,
      memo,
      funds
    )
  }
  receive = async (
    {
      amount,
      msg,
      sender,
    }: {
      amount: string
      msg: string
      sender: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        receive: {
          amount,
          msg,
          sender,
        },
      },
      fee,
      memo,
      funds
    )
  }
  pay = async (
    {
      osId,
    }: {
      osId: number
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        pay: {
          os_id: osId,
        },
      },
      fee,
      memo,
      funds
    )
  }
  unsubscribe = async (
    {
      osIds,
    }: {
      osIds: number[]
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        unsubscribe: {
          os_ids: osIds,
        },
      },
      fee,
      memo,
      funds
    )
  }
  claimCompensation = async (
    {
      osId,
    }: {
      osId: number
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        claim_compensation: {
          os_id: osId,
        },
      },
      fee,
      memo,
      funds
    )
  }
  claimEmissions = async (
    {
      osId,
    }: {
      osId: number
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        claim_emissions: {
          os_id: osId,
        },
      },
      fee,
      memo,
      funds
    )
  }
  updateContributor = async (
    {
      basePerBlock,
      contributorOsId,
      expirationBlock,
      weight,
    }: {
      basePerBlock?: Decimal
      contributorOsId: number
      expirationBlock?: Uint64
      weight?: Uint64
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_contributor: {
          base_per_block: basePerBlock,
          contributor_os_id: contributorOsId,
          expiration_block: expirationBlock,
          weight,
        },
      },
      fee,
      memo,
      funds
    )
  }
  removeContributor = async (
    {
      osId,
    }: {
      osId: number
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        remove_contributor: {
          os_id: osId,
        },
      },
      fee,
      memo,
      funds
    )
  }
  updateSubscriptionConfig = async (
    {
      factoryAddress,
      paymentAsset,
      subscriptionCost,
      versionControlAddress,
    }: {
      factoryAddress?: string
      paymentAsset?: AssetInfoBaseFor_String
      subscriptionCost?: Decimal
      versionControlAddress?: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_subscription_config: {
          factory_address: factoryAddress,
          payment_asset: paymentAsset,
          subscription_cost: subscriptionCost,
          version_control_address: versionControlAddress,
        },
      },
      fee,
      memo,
      funds
    )
  }
  updateContributionConfig = async (
    {
      emissionUserShare,
      emissionsAmpFactor,
      emissionsOffset,
      maxEmissionsMultiple,
      projectTokenInfo,
      protocolIncomeShare,
    }: {
      emissionUserShare?: Decimal
      emissionsAmpFactor?: Uint128
      emissionsOffset?: Uint128
      maxEmissionsMultiple?: Decimal
      projectTokenInfo?: AssetInfoBaseFor_String
      protocolIncomeShare?: Decimal
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    funds?: readonly Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_contribution_config: {
          emission_user_share: emissionUserShare,
          emissions_amp_factor: emissionsAmpFactor,
          emissions_offset: emissionsOffset,
          max_emissions_multiple: maxEmissionsMultiple,
          project_token_info: projectTokenInfo,
          protocol_income_share: protocolIncomeShare,
        },
      },
      fee,
      memo,
      funds
    )
  }
}
