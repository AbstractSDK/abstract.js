/**
* This file was automatically generated by cosmwasm-typescript-gen@0.2.15.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the cosmwasm-typescript-gen generate command to regenerate this file.
*/

import { CosmWasmClient, ExecuteResult, SigningCosmWasmClient } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
export type Addr = string;
export interface AddOnState {
  memory: Memory;
  proxy_address: Addr;
}
export interface Memory {
  address: Addr;
}
export type AssetInfoBaseFor_Addr = {
  cw20: Addr;
} | {
  native: string;
};
export type Decimal = string;
export type Uint128 = string;
export type Uint64 = string;
export interface ConfigResponse {
  contribution: ContributionConfig;
  subscription: SubscriptionConfig;
}
export interface ContributionConfig {
  base_denom: string;
  emission_user_share: Decimal;
  emissions_amp_factor: Uint128;
  emissions_offset: Uint128;
  max_emissions_multiple: Decimal;
  project_token: Addr;
  protocol_income_share: Decimal;
}
export interface SubscriptionConfig {
  factory_address: Addr;
  payment_asset: AssetInfoBaseFor_Addr;
  subscription_cost: Uint64;
  version_control_address: Addr;
}
export interface ContributorStateResponse {
  compensation: Compensation;
}
export interface Compensation {
  base: number;
  expiration: Uint64;
  next_pay_day: Uint64;
  weight: number;
}
export interface FeeResponse {
  fee: AssetBaseFor_Addr;
}
export interface AssetBaseFor_Addr {
  amount: Uint128;
  info: AssetInfoBaseFor_Addr;
}
export type AssetInfoBaseFor_String = {
  cw20: string;
} | {
  native: string;
};
export interface InstantiateMsg {
  base: AddOnInstantiateMsg;
  contribution: ContributionInstantiateMsg;
  subscription: SubscriptionInstantiateMsg;
}
export interface AddOnInstantiateMsg {
  memory_address: string;
}
export interface ContributionInstantiateMsg {
  base_denom: string;
  emission_user_share: Decimal;
  emissions_amp_factor: Uint128;
  emissions_offset: Uint128;
  max_emissions_multiple: Decimal;
  project_token: string;
  protocol_income_share: Decimal;
}
export interface SubscriptionInstantiateMsg {
  factory_addr: string;
  payment_asset: AssetInfoBaseFor_String;
  subscription_cost: Uint64;
  version_control_addr: string;
}
export interface StateResponse {
  contribution: ContributionState;
  subscription: SubscriptionState;
}
export interface ContributionState {
  emissions: Uint128;
  expense: Uint64;
  next_pay_day: Uint64;
  target: Uint64;
  total_weight: Uint128;
}
export interface SubscriptionState {
  active_subs: number;
  collected: boolean;
  income: Uint64;
}
export interface SubscriberStateResponse {
  currently_subscribed: boolean;
  subscriber_details: Subscriber;
}
export interface Subscriber {
  balance: Deposit;
  claimed_emissions: boolean;
  manager_addr: Addr;
}
export interface Deposit {
  value: Uint64;
}
export interface SubscriptionReadOnlyInterface {
  contractAddress: string;
  base: () => Promise<any>;
  state: () => Promise<StateResponse>;
  config: () => Promise<ConfigResponse>;
  fee: () => Promise<FeeResponse>;
  subscriberState: ({
    osId
  }: {
    osId: number;
  }) => Promise<SubscriberStateResponse>;
  contributorState: ({
    contributorAddr
  }: {
    contributorAddr: string;
  }) => Promise<ContributorStateResponse>;
}
export class SubscriptionQueryClient implements SubscriptionReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.base = this.base.bind(this);
    this.state = this.state.bind(this);
    this.config = this.config.bind(this);
    this.fee = this.fee.bind(this);
    this.subscriberState = this.subscriberState.bind(this);
    this.contributorState = this.contributorState.bind(this);
  }

  base = async (): Promise<any> => {
    return this.client.queryContractSmart(this.contractAddress, {
      base: {}
    });
  };
  state = async (): Promise<StateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      state: {}
    });
  };
  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  fee = async (): Promise<FeeResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      fee: {}
    });
  };
  subscriberState = async ({
    osId
  }: {
    osId: number;
  }): Promise<SubscriberStateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      subscriber_state: {
        os_id: osId
      }
    });
  };
  contributorState = async ({
    contributorAddr
  }: {
    contributorAddr: string;
  }): Promise<ContributorStateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      contributor_state: {
        contributor_addr: contributorAddr
      }
    });
  };
}
export interface SubscriptionInterface extends SubscriptionReadOnlyInterface {
  contractAddress: string;
  sender: string;
  base: (fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  receive: (fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  pay: ({
    osId
  }: {
    osId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  collectSubs: ({
    pageLimit
  }: {
    pageLimit?: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  claimCompensation: ({
    contributor,
    pageLimit
  }: {
    contributor?: string;
    pageLimit?: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  claimEmissions: ({
    osId
  }: {
    osId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  updateContributor: ({
    compensation,
    contributorAddr
  }: {
    compensation: Compensation;
    contributorAddr: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  removeContributor: ({
    contributorAddr
  }: {
    contributorAddr: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  updateSubscriptionConfig: ({
    factoryAddress,
    paymentAsset,
    subscriptionCost,
    versionControlAddress
  }: {
    factoryAddress?: string;
    paymentAsset?: AssetInfoBaseFor_Addr;
    subscriptionCost?: Uint64;
    versionControlAddress?: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
  updateContributionConfig: ({
    baseDenom,
    emissionUserShare,
    emissionsAmpFactor,
    emissionsOffset,
    maxEmissionsMultiple,
    projectToken,
    protocolIncomeShare
  }: {
    baseDenom?: string;
    emissionUserShare?: Decimal;
    emissionsAmpFactor?: Uint128;
    emissionsOffset?: Uint128;
    maxEmissionsMultiple?: Decimal;
    projectToken?: string;
    protocolIncomeShare?: Decimal;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: readonly Coin[]) => Promise<ExecuteResult>;
}
export class SubscriptionClient extends SubscriptionQueryClient implements SubscriptionInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.base = this.base.bind(this);
    this.receive = this.receive.bind(this);
    this.pay = this.pay.bind(this);
    this.collectSubs = this.collectSubs.bind(this);
    this.claimCompensation = this.claimCompensation.bind(this);
    this.claimEmissions = this.claimEmissions.bind(this);
    this.updateContributor = this.updateContributor.bind(this);
    this.removeContributor = this.removeContributor.bind(this);
    this.updateSubscriptionConfig = this.updateSubscriptionConfig.bind(this);
    this.updateContributionConfig = this.updateContributionConfig.bind(this);
  }

  base = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      base: {}
    }, fee, memo, funds);
  };
  receive = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive: {}
    }, fee, memo, funds);
  };
  pay = async ({
    osId
  }: {
    osId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      pay: {
        os_id: osId
      }
    }, fee, memo, funds);
  };
  collectSubs = async ({
    pageLimit
  }: {
    pageLimit?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      collect_subs: {
        page_limit: pageLimit
      }
    }, fee, memo, funds);
  };
  claimCompensation = async ({
    contributor,
    pageLimit
  }: {
    contributor?: string;
    pageLimit?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_compensation: {
        contributor,
        page_limit: pageLimit
      }
    }, fee, memo, funds);
  };
  claimEmissions = async ({
    osId
  }: {
    osId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_emissions: {
        os_id: osId
      }
    }, fee, memo, funds);
  };
  updateContributor = async ({
    compensation,
    contributorAddr
  }: {
    compensation: Compensation;
    contributorAddr: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_contributor: {
        compensation,
        contributor_addr: contributorAddr
      }
    }, fee, memo, funds);
  };
  removeContributor = async ({
    contributorAddr
  }: {
    contributorAddr: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_contributor: {
        contributor_addr: contributorAddr
      }
    }, fee, memo, funds);
  };
  updateSubscriptionConfig = async ({
    factoryAddress,
    paymentAsset,
    subscriptionCost,
    versionControlAddress
  }: {
    factoryAddress?: string;
    paymentAsset?: AssetInfoBaseFor_Addr;
    subscriptionCost?: Uint64;
    versionControlAddress?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_subscription_config: {
        factory_address: factoryAddress,
        payment_asset: paymentAsset,
        subscription_cost: subscriptionCost,
        version_control_address: versionControlAddress
      }
    }, fee, memo, funds);
  };
  updateContributionConfig = async ({
    baseDenom,
    emissionUserShare,
    emissionsAmpFactor,
    emissionsOffset,
    maxEmissionsMultiple,
    projectToken,
    protocolIncomeShare
  }: {
    baseDenom?: string;
    emissionUserShare?: Decimal;
    emissionsAmpFactor?: Uint128;
    emissionsOffset?: Uint128;
    maxEmissionsMultiple?: Decimal;
    projectToken?: string;
    protocolIncomeShare?: Decimal;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_contribution_config: {
        base_denom: baseDenom,
        emission_user_share: emissionUserShare,
        emissions_amp_factor: emissionsAmpFactor,
        emissions_offset: emissionsOffset,
        max_emissions_multiple: maxEmissionsMultiple,
        project_token: projectToken,
        protocol_income_share: protocolIncomeShare
      }
    }, fee, memo, funds);
  };
}
