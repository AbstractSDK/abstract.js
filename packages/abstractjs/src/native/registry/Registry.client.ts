/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.28.0.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from '@cosmjs/cosmwasm-stargate'
import { StdFee } from '@cosmjs/amino'
import {
  Uint128,
  InstantiateMsg,
  Coin,
  ExecuteMsg,
  Namespace,
  ModuleVersion,
  ModuleReference,
  Addr,
  Monetization,
  Action,
  Expiration,
  Timestamp,
  Uint64,
  ModuleInfo,
  FixedFee,
  AccountBase,
  QueryMsg,
  ModuleStatus,
  ModuleFilter,
  MigrateMsg,
  AccountBaseResponse,
  ConfigResponse,
  ModulesListResponse,
  ModuleResponse,
  ModuleConfiguration,
  Module,
  ModulesResponse,
  NamespaceResponse,
  NamespaceListResponse,
  NamespacesResponse,
  OwnershipForString,
} from './Registry.types'
export interface RegistryReadOnlyInterface {
  contractAddress: string
  accountBase: ({ accountId }: { accountId: number }) => Promise<AccountBaseResponse>
  modules: ({ infos }: { infos: ModuleInfo[] }) => Promise<ModulesResponse>
  namespaces: ({ accounts }: { accounts: number[] }) => Promise<NamespacesResponse>
  namespace: ({ namespace }: { namespace: Namespace }) => Promise<NamespaceResponse>
  config: () => Promise<ConfigResponse>
  moduleList: ({
    filter,
    limit,
    startAfter,
  }: {
    filter?: ModuleFilter
    limit?: number
    startAfter?: ModuleInfo
  }) => Promise<ModulesListResponse>
  namespaceList: ({
    limit,
    startAfter,
  }: {
    limit?: number
    startAfter?: string
  }) => Promise<NamespaceListResponse>
  ownership: () => Promise<OwnershipForString>
}
export class RegistryQueryClient implements RegistryReadOnlyInterface {
  client: CosmWasmClient
  contractAddress: string

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client
    this.contractAddress = contractAddress
    this.accountBase = this.accountBase.bind(this)
    this.modules = this.modules.bind(this)
    this.namespaces = this.namespaces.bind(this)
    this.namespace = this.namespace.bind(this)
    this.config = this.config.bind(this)
    this.moduleList = this.moduleList.bind(this)
    this.namespaceList = this.namespaceList.bind(this)
    this.ownership = this.ownership.bind(this)
  }

  accountBase = async ({ accountId }: { accountId: number }): Promise<AccountBaseResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      account_base: {
        account_id: accountId,
      },
    })
  }
  modules = async ({ infos }: { infos: ModuleInfo[] }): Promise<ModulesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      modules: {
        infos,
      },
    })
  }
  namespaces = async ({ accounts }: { accounts: number[] }): Promise<NamespacesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      namespaces: {
        accounts,
      },
    })
  }
  namespace = async ({ namespace }: { namespace: Namespace }): Promise<NamespaceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      namespace: {
        namespace,
      },
    })
  }
  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {},
    })
  }
  moduleList = async ({
    filter,
    limit,
    startAfter,
  }: {
    filter?: ModuleFilter
    limit?: number
    startAfter?: ModuleInfo
  }): Promise<ModulesListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      module_list: {
        filter,
        limit,
        start_after: startAfter,
      },
    })
  }
  namespaceList = async ({
    limit,
    startAfter,
  }: {
    limit?: number
    startAfter?: string
  }): Promise<NamespaceListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      namespace_list: {
        limit,
        start_after: startAfter,
      },
    })
  }
  ownership = async (): Promise<OwnershipForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ownership: {},
    })
  }
}
export interface RegistryInterface extends RegistryReadOnlyInterface {
  contractAddress: string
  sender: string
  removeModule: (
    {
      module,
    }: {
      module: ModuleInfo
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  yankModule: (
    {
      module,
    }: {
      module: ModuleInfo
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  proposeModules: (
    {
      modules,
    }: {
      modules: ModuleInfo[][]
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  setModuleMonetization: (
    {
      moduleName,
      monetization,
      namespace,
    }: {
      moduleName: string
      monetization: Monetization
      namespace: Namespace
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  setModuleMetadata: (
    {
      metadata,
      module,
    }: {
      metadata: string
      module: ModuleInfo
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  approveOrRejectModules: (
    {
      approves,
      rejects,
    }: {
      approves: ModuleInfo[]
      rejects: ModuleInfo[]
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  claimNamespace: (
    {
      accountId,
      namespace,
    }: {
      accountId: number
      namespace: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  removeNamespaces: (
    {
      namespaces,
    }: {
      namespaces: string[]
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  addAccount: (
    {
      accountBase,
      accountId,
    }: {
      accountBase: AccountBase
      accountId: number
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  updateConfig: (
    {
      allowDirectModuleRegistrationAndUpdates,
      namespaceRegistrationFee,
    }: {
      allowDirectModuleRegistrationAndUpdates?: boolean
      namespaceRegistrationFee?: Coin
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  setFactory: (
    {
      newFactory,
    }: {
      newFactory: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
  updateOwnership: (
    action: Action,
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>
}
export class RegistryClient extends RegistryQueryClient implements RegistryInterface {
  client: SigningCosmWasmClient
  sender: string
  contractAddress: string

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress)
    this.client = client
    this.sender = sender
    this.contractAddress = contractAddress
    this.removeModule = this.removeModule.bind(this)
    this.yankModule = this.yankModule.bind(this)
    this.proposeModules = this.proposeModules.bind(this)
    this.setModuleMonetization = this.setModuleMonetization.bind(this)
    this.setModuleMetadata = this.setModuleMetadata.bind(this)
    this.approveOrRejectModules = this.approveOrRejectModules.bind(this)
    this.claimNamespace = this.claimNamespace.bind(this)
    this.removeNamespaces = this.removeNamespaces.bind(this)
    this.addAccount = this.addAccount.bind(this)
    this.updateConfig = this.updateConfig.bind(this)
    this.setFactory = this.setFactory.bind(this)
    this.updateOwnership = this.updateOwnership.bind(this)
  }

  removeModule = async (
    {
      module,
    }: {
      module: ModuleInfo
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        remove_module: {
          module,
        },
      },
      fee,
      memo,
      _funds
    )
  }
  yankModule = async (
    {
      module,
    }: {
      module: ModuleInfo
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        yank_module: {
          module,
        },
      },
      fee,
      memo,
      _funds
    )
  }
  proposeModules = async (
    {
      modules,
    }: {
      modules: ModuleInfo[][]
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        propose_modules: {
          modules,
        },
      },
      fee,
      memo,
      _funds
    )
  }
  setModuleMonetization = async (
    {
      moduleName,
      monetization,
      namespace,
    }: {
      moduleName: string
      monetization: Monetization
      namespace: Namespace
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        set_module_monetization: {
          module_name: moduleName,
          monetization,
          namespace,
        },
      },
      fee,
      memo,
      _funds
    )
  }
  setModuleMetadata = async (
    {
      metadata,
      module,
    }: {
      metadata: string
      module: ModuleInfo
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        set_module_metadata: {
          metadata,
          module,
        },
      },
      fee,
      memo,
      _funds
    )
  }
  approveOrRejectModules = async (
    {
      approves,
      rejects,
    }: {
      approves: ModuleInfo[]
      rejects: ModuleInfo[]
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        approve_or_reject_modules: {
          approves,
          rejects,
        },
      },
      fee,
      memo,
      _funds
    )
  }
  claimNamespace = async (
    {
      accountId,
      namespace,
    }: {
      accountId: number
      namespace: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        claim_namespace: {
          account_id: accountId,
          namespace,
        },
      },
      fee,
      memo,
      _funds
    )
  }
  removeNamespaces = async (
    {
      namespaces,
    }: {
      namespaces: string[]
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        remove_namespaces: {
          namespaces,
        },
      },
      fee,
      memo,
      _funds
    )
  }
  addAccount = async (
    {
      accountBase,
      accountId,
    }: {
      accountBase: AccountBase
      accountId: number
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        add_account: {
          account_base: accountBase,
          account_id: accountId,
        },
      },
      fee,
      memo,
      _funds
    )
  }
  updateConfig = async (
    {
      allowDirectModuleRegistrationAndUpdates,
      namespaceRegistrationFee,
    }: {
      allowDirectModuleRegistrationAndUpdates?: boolean
      namespaceRegistrationFee?: Coin
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_config: {
          allow_direct_module_registration_and_updates: allowDirectModuleRegistrationAndUpdates,
          namespace_registration_fee: namespaceRegistrationFee,
        },
      },
      fee,
      memo,
      _funds
    )
  }
  setFactory = async (
    {
      newFactory,
    }: {
      newFactory: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        set_factory: {
          new_factory: newFactory,
        },
      },
      fee,
      memo,
      _funds
    )
  }
  updateOwnership = async (
    action: Action,
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_ownership: action,
      },
      fee,
      memo,
      _funds
    )
  }
}
