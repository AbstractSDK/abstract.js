/**
 * This file was automatically generated by @abstract-money/ts-codegen@0.35.4.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @abstract-money/ts-codegen generate command to regenerate this file.
 */

import { StdFee } from '@cosmjs/amino'
import {
  CosmWasmClient,
  ExecuteResult,
  SigningCosmWasmClient,
} from '@cosmjs/cosmwasm-stargate'
import {
  AccountBase,
  AccountBaseResponse,
  AccountId,
  AccountTrace,
  Action,
  Addr,
  ChainName,
  Coin,
  ConfigResponse,
  ExecuteMsg,
  Expiration,
  FixedFee,
  InstantiateMsg,
  MigrateMsg,
  Module,
  ModuleConfiguration,
  ModuleFilter,
  ModuleInfo,
  ModuleReference,
  ModuleResponse,
  ModuleStatus,
  ModuleVersion,
  ModulesListResponse,
  ModulesResponse,
  Monetization,
  Namespace,
  NamespaceListResponse,
  NamespaceResponse,
  NamespacesResponse,
  OwnershipForString,
  QueryMsg,
  Timestamp,
  Uint64,
  Uint128,
  UpdateModule,
} from './VersionControl.types'
export interface VersionControlReadOnlyInterface {
  contractAddress: string
  accountBase: ({
    accountId,
  }: {
    accountId: AccountId
  }) => Promise<AccountBaseResponse>
  modules: ({
    infos,
  }: {
    infos: ModuleInfo[]
  }) => Promise<ModulesResponse>
  namespaces: ({
    accounts,
  }: {
    accounts: AccountId[]
  }) => Promise<NamespacesResponse>
  namespace: ({
    namespace,
  }: {
    namespace: Namespace
  }) => Promise<NamespaceResponse>
  config: () => Promise<ConfigResponse>
  moduleList: ({
    filter,
    limit,
    startAfter,
  }: {
    filter?: ModuleFilter
    limit?: number
    startAfter?: ModuleInfo
  }) => Promise<ModulesListResponse>
  namespaceList: ({
    limit,
    startAfter,
  }: {
    limit?: number
    startAfter?: string
  }) => Promise<NamespaceListResponse>
  ownership: () => Promise<OwnershipForString>
}
export class VersionControlQueryClient
  implements VersionControlReadOnlyInterface
{
  client: CosmWasmClient
  contractAddress: string

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client
    this.contractAddress = contractAddress
    this.accountBase = this.accountBase.bind(this)
    this.modules = this.modules.bind(this)
    this.namespaces = this.namespaces.bind(this)
    this.namespace = this.namespace.bind(this)
    this.config = this.config.bind(this)
    this.moduleList = this.moduleList.bind(this)
    this.namespaceList = this.namespaceList.bind(this)
    this.ownership = this.ownership.bind(this)
  }

  accountBase = async ({
    accountId,
  }: {
    accountId: AccountId
  }): Promise<AccountBaseResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      account_base: {
        account_id: accountId,
      },
    })
  }
  modules = async ({
    infos,
  }: {
    infos: ModuleInfo[]
  }): Promise<ModulesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      modules: {
        infos,
      },
    })
  }
  namespaces = async ({
    accounts,
  }: {
    accounts: AccountId[]
  }): Promise<NamespacesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      namespaces: {
        accounts,
      },
    })
  }
  namespace = async ({
    namespace,
  }: {
    namespace: Namespace
  }): Promise<NamespaceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      namespace: {
        namespace,
      },
    })
  }
  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {},
    })
  }
  moduleList = async ({
    filter,
    limit,
    startAfter,
  }: {
    filter?: ModuleFilter
    limit?: number
    startAfter?: ModuleInfo
  }): Promise<ModulesListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      module_list: {
        filter,
        limit,
        start_after: startAfter,
      },
    })
  }
  namespaceList = async ({
    limit,
    startAfter,
  }: {
    limit?: number
    startAfter?: string
  }): Promise<NamespaceListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      namespace_list: {
        limit,
        start_after: startAfter,
      },
    })
  }
  ownership = async (): Promise<OwnershipForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ownership: {},
    })
  }
}
export interface VersionControlInterface
  extends VersionControlReadOnlyInterface {
  contractAddress: string
  sender: string
  removeModule: (
    {
      module,
    }: {
      module: ModuleInfo
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  yankModule: (
    {
      module,
    }: {
      module: ModuleInfo
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  proposeModules: (
    {
      modules,
    }: {
      modules: ModuleInfo[][]
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  updateModuleConfiguration: (
    {
      moduleName,
      namespace,
      updateModule,
    }: {
      moduleName: string
      namespace: Namespace
      updateModule: UpdateModule
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  approveOrRejectModules: (
    {
      approves,
      rejects,
    }: {
      approves: ModuleInfo[]
      rejects: ModuleInfo[]
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  claimNamespace: (
    {
      accountId,
      namespace,
    }: {
      accountId: AccountId
      namespace: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  removeNamespaces: (
    {
      namespaces,
    }: {
      namespaces: string[]
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  addAccount: (
    {
      accountBase,
      accountId,
    }: {
      accountBase: AccountBase
      accountId: AccountId
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  updateConfig: (
    {
      allowDirectModuleRegistrationAndUpdates,
      namespaceRegistrationFee,
    }: {
      allowDirectModuleRegistrationAndUpdates?: boolean
      namespaceRegistrationFee?: Coin
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  setFactory: (
    {
      newFactory,
    }: {
      newFactory: string
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  updateOwnership: (
    action: Action,
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
}
export class VersionControlClient
  extends VersionControlQueryClient
  implements VersionControlInterface
{
  client: SigningCosmWasmClient
  sender: string
  contractAddress: string

  constructor(
    client: SigningCosmWasmClient,
    sender: string,
    contractAddress: string,
  ) {
    super(client, contractAddress)
    this.client = client
    this.sender = sender
    this.contractAddress = contractAddress
    this.removeModule = this.removeModule.bind(this)
    this.yankModule = this.yankModule.bind(this)
    this.proposeModules = this.proposeModules.bind(this)
    this.updateModuleConfiguration = this.updateModuleConfiguration.bind(this)
    this.approveOrRejectModules = this.approveOrRejectModules.bind(this)
    this.claimNamespace = this.claimNamespace.bind(this)
    this.removeNamespaces = this.removeNamespaces.bind(this)
    this.addAccount = this.addAccount.bind(this)
    this.updateConfig = this.updateConfig.bind(this)
    this.setFactory = this.setFactory.bind(this)
    this.updateOwnership = this.updateOwnership.bind(this)
  }

  removeModule = async (
    {
      module,
    }: {
      module: ModuleInfo
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        remove_module: {
          module,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  yankModule = async (
    {
      module,
    }: {
      module: ModuleInfo
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        yank_module: {
          module,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  proposeModules = async (
    {
      modules,
    }: {
      modules: ModuleInfo[][]
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        propose_modules: {
          modules,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  updateModuleConfiguration = async (
    {
      moduleName,
      namespace,
      updateModule,
    }: {
      moduleName: string
      namespace: Namespace
      updateModule: UpdateModule
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_module_configuration: {
          module_name: moduleName,
          namespace,
          update_module: updateModule,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  approveOrRejectModules = async (
    {
      approves,
      rejects,
    }: {
      approves: ModuleInfo[]
      rejects: ModuleInfo[]
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        approve_or_reject_modules: {
          approves,
          rejects,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  claimNamespace = async (
    {
      accountId,
      namespace,
    }: {
      accountId: AccountId
      namespace: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        claim_namespace: {
          account_id: accountId,
          namespace,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  removeNamespaces = async (
    {
      namespaces,
    }: {
      namespaces: string[]
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        remove_namespaces: {
          namespaces,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  addAccount = async (
    {
      accountBase,
      accountId,
    }: {
      accountBase: AccountBase
      accountId: AccountId
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        add_account: {
          account_base: accountBase,
          account_id: accountId,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  updateConfig = async (
    {
      allowDirectModuleRegistrationAndUpdates,
      namespaceRegistrationFee,
    }: {
      allowDirectModuleRegistrationAndUpdates?: boolean
      namespaceRegistrationFee?: Coin
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_config: {
          allow_direct_module_registration_and_updates:
            allowDirectModuleRegistrationAndUpdates,
          namespace_registration_fee: namespaceRegistrationFee,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  setFactory = async (
    {
      newFactory,
    }: {
      newFactory: string
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        set_factory: {
          new_factory: newFactory,
        },
      },
      fee,
      memo,
      _funds,
    )
  }
  updateOwnership = async (
    action: Action,
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_ownership: action,
      },
      fee,
      memo,
      _funds,
    )
  }
}
