/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.28.0.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import { CamelCasedProperties } from 'type-fest'
import { SigningCosmWasmClient, ExecuteResult } from '@cosmjs/cosmwasm-stargate'
import {
  AbstractQueryClient,
  AbstractAccountQueryClient,
  AbstractAccountClient,
  AppExecuteMsg,
  AppExecuteMsgFactory,
  AbstractClient,
  AbstractAccountId,
} from '../..'
import { StdFee, Coin } from '@cosmjs/amino'
import {
  Threshold,
  Decimal,
  Uint64,
  InstantiateMsg,
  VoteConfig,
  ExecuteMsg,
  FriendForString,
  AccountTrace,
  ChainName,
  AssetEntry,
  StrikeStrategy,
  Uint128,
  UpdateFriendsOpKind,
  ChallengeRequest,
  FriendByAddrForString,
  AccountId,
  ChallengeEntryUpdate,
  Vote,
  QueryMsg,
  Addr,
  MigrateMsg,
  Timestamp,
  ProposalStatus,
  ProposalOutcome,
  ChallengeResponse,
  ChallengeEntryResponse,
  ProposalInfo,
  AdminStrikes,
  ChallengesResponse,
  FriendForAddr,
  FriendsResponse,
  FriendByAddrForAddr,
  ProposalsResponse,
  VoteResponse,
  VotesResponse,
} from './Challenge.types'
import {
  ChallengeQueryMsgBuilder,
  ChallengeExecuteMsgBuilder,
} from './Challenge.msg-builder'
export interface IChallengeAppQueryClient {
  moduleId: string
  accountQueryClient: AbstractAccountQueryClient
  _moduleAddress: string | undefined
  challenge: (
    params: CamelCasedProperties<
      Extract<
        QueryMsg,
        {
          challenge: unknown
        }
      >['challenge']
    >,
  ) => Promise<ChallengeResponse>
  challenges: (
    params: CamelCasedProperties<
      Extract<
        QueryMsg,
        {
          challenges: unknown
        }
      >['challenges']
    >,
  ) => Promise<ChallengesResponse>
  friends: (
    params: CamelCasedProperties<
      Extract<
        QueryMsg,
        {
          friends: unknown
        }
      >['friends']
    >,
  ) => Promise<FriendsResponse>
  vote: (
    params: CamelCasedProperties<
      Extract<
        QueryMsg,
        {
          vote: unknown
        }
      >['vote']
    >,
  ) => Promise<VoteResponse>
  votes: (
    params: CamelCasedProperties<
      Extract<
        QueryMsg,
        {
          votes: unknown
        }
      >['votes']
    >,
  ) => Promise<VotesResponse>
  proposals: (
    params: CamelCasedProperties<
      Extract<
        QueryMsg,
        {
          proposals: unknown
        }
      >['proposals']
    >,
  ) => Promise<ProposalsResponse>
  connectSigningClient: (
    signingClient: SigningCosmWasmClient,
    address: string,
  ) => ChallengeAppClient
  address: () => Promise<string>
}
export class ChallengeAppQueryClient implements IChallengeAppQueryClient {
  accountQueryClient: AbstractAccountQueryClient
  moduleId: string
  _moduleAddress: string | undefined

  constructor({
    abstractQueryClient,
    accountId,
    managerAddress,
    proxyAddress,
    moduleId,
  }: {
    abstractQueryClient: AbstractQueryClient
    accountId: AbstractAccountId
    managerAddress: string
    proxyAddress: string
    moduleId: string
  }) {
    this.accountQueryClient = new AbstractAccountQueryClient({
      abstract: abstractQueryClient,
      accountId,
      managerAddress,
      proxyAddress,
    })
    this.moduleId = moduleId
    this.challenge = this.challenge.bind(this)
    this.challenges = this.challenges.bind(this)
    this.friends = this.friends.bind(this)
    this.vote = this.vote.bind(this)
    this.votes = this.votes.bind(this)
    this.proposals = this.proposals.bind(this)
  }

  challenge = async (
    params: CamelCasedProperties<
      Extract<
        QueryMsg,
        {
          challenge: unknown
        }
      >['challenge']
    >,
  ): Promise<ChallengeResponse> => {
    return this._query(ChallengeQueryMsgBuilder.challenge(params))
  }
  challenges = async (
    params: CamelCasedProperties<
      Extract<
        QueryMsg,
        {
          challenges: unknown
        }
      >['challenges']
    >,
  ): Promise<ChallengesResponse> => {
    return this._query(ChallengeQueryMsgBuilder.challenges(params))
  }
  friends = async (
    params: CamelCasedProperties<
      Extract<
        QueryMsg,
        {
          friends: unknown
        }
      >['friends']
    >,
  ): Promise<FriendsResponse> => {
    return this._query(ChallengeQueryMsgBuilder.friends(params))
  }
  vote = async (
    params: CamelCasedProperties<
      Extract<
        QueryMsg,
        {
          vote: unknown
        }
      >['vote']
    >,
  ): Promise<VoteResponse> => {
    return this._query(ChallengeQueryMsgBuilder.vote(params))
  }
  votes = async (
    params: CamelCasedProperties<
      Extract<
        QueryMsg,
        {
          votes: unknown
        }
      >['votes']
    >,
  ): Promise<VotesResponse> => {
    return this._query(ChallengeQueryMsgBuilder.votes(params))
  }
  proposals = async (
    params: CamelCasedProperties<
      Extract<
        QueryMsg,
        {
          proposals: unknown
        }
      >['proposals']
    >,
  ): Promise<ProposalsResponse> => {
    return this._query(ChallengeQueryMsgBuilder.proposals(params))
  }
  address = async (): Promise<string> => {
    if (!this._moduleAddress) {
      const address = await this.accountQueryClient.getModuleAddress(
        this.moduleId,
      )
      if (address === null) {
        throw new Error(`${this.moduleId} is not installed`)
      }
      this._moduleAddress = address
    }

    return this._moduleAddress
  }
  connectSigningClient = (
    signingClient: SigningCosmWasmClient,
    address: string,
  ): ChallengeAppClient => {
    return new ChallengeAppClient({
      accountId: this.accountQueryClient.accountId,
      managerAddress: this.accountQueryClient.managerAddress,
      proxyAddress: this.accountQueryClient.proxyAddress,
      moduleId: this.moduleId,
      abstractClient: this.accountQueryClient.abstract.connectSigningClient(
        signingClient,
        address,
      ),
    })
  }
  _query = async (queryMsg: QueryMsg): Promise<any> => {
    return this.accountQueryClient.queryModule({
      moduleId: this.moduleId,
      moduleType: 'app',
      queryMsg,
    })
  }
}
export interface IChallengeAppClient extends IChallengeAppQueryClient {
  accountClient: AbstractAccountClient
  updateConfig: (
    params: CamelCasedProperties<
      Extract<
        ExecuteMsg,
        {
          update_config: unknown
        }
      >['update_config']
    >,
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  createChallenge: (
    params: CamelCasedProperties<
      Extract<
        ExecuteMsg,
        {
          create_challenge: unknown
        }
      >['create_challenge']
    >,
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  updateChallenge: (
    params: CamelCasedProperties<
      Extract<
        ExecuteMsg,
        {
          update_challenge: unknown
        }
      >['update_challenge']
    >,
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  cancelChallenge: (
    params: CamelCasedProperties<
      Extract<
        ExecuteMsg,
        {
          cancel_challenge: unknown
        }
      >['cancel_challenge']
    >,
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  updateFriendsForChallenge: (
    params: CamelCasedProperties<
      Extract<
        ExecuteMsg,
        {
          update_friends_for_challenge: unknown
        }
      >['update_friends_for_challenge']
    >,
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  castVote: (
    params: CamelCasedProperties<
      Extract<
        ExecuteMsg,
        {
          cast_vote: unknown
        }
      >['cast_vote']
    >,
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  countVotes: (
    params: CamelCasedProperties<
      Extract<
        ExecuteMsg,
        {
          count_votes: unknown
        }
      >['count_votes']
    >,
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
  veto: (
    params: CamelCasedProperties<
      Extract<
        ExecuteMsg,
        {
          veto: unknown
        }
      >['veto']
    >,
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[],
  ) => Promise<ExecuteResult>
}
export class ChallengeAppClient
  extends ChallengeAppQueryClient
  implements IChallengeAppClient
{
  accountClient: AbstractAccountClient

  constructor({
    abstractClient,
    accountId,
    managerAddress,
    proxyAddress,
    moduleId,
  }: {
    abstractClient: AbstractClient
    accountId: AbstractAccountId
    managerAddress: string
    proxyAddress: string
    moduleId: string
  }) {
    super({
      abstractQueryClient: abstractClient,
      accountId,
      managerAddress,
      proxyAddress,
      moduleId,
    })
    this.accountClient = AbstractAccountClient.fromQueryClient(
      this.accountQueryClient,
      abstractClient,
    )
    this.updateConfig = this.updateConfig.bind(this)
    this.createChallenge = this.createChallenge.bind(this)
    this.updateChallenge = this.updateChallenge.bind(this)
    this.cancelChallenge = this.cancelChallenge.bind(this)
    this.updateFriendsForChallenge = this.updateFriendsForChallenge.bind(this)
    this.castVote = this.castVote.bind(this)
    this.countVotes = this.countVotes.bind(this)
    this.veto = this.veto.bind(this)
  }

  updateConfig = async (
    params: CamelCasedProperties<
      Extract<
        ExecuteMsg,
        {
          update_config: unknown
        }
      >['update_config']
    >,
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return this._execute(
      ChallengeExecuteMsgBuilder.updateConfig(params),
      fee,
      memo,
      _funds,
    )
  }
  createChallenge = async (
    params: CamelCasedProperties<
      Extract<
        ExecuteMsg,
        {
          create_challenge: unknown
        }
      >['create_challenge']
    >,
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return this._execute(
      ChallengeExecuteMsgBuilder.createChallenge(params),
      fee,
      memo,
      _funds,
    )
  }
  updateChallenge = async (
    params: CamelCasedProperties<
      Extract<
        ExecuteMsg,
        {
          update_challenge: unknown
        }
      >['update_challenge']
    >,
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return this._execute(
      ChallengeExecuteMsgBuilder.updateChallenge(params),
      fee,
      memo,
      _funds,
    )
  }
  cancelChallenge = async (
    params: CamelCasedProperties<
      Extract<
        ExecuteMsg,
        {
          cancel_challenge: unknown
        }
      >['cancel_challenge']
    >,
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return this._execute(
      ChallengeExecuteMsgBuilder.cancelChallenge(params),
      fee,
      memo,
      _funds,
    )
  }
  updateFriendsForChallenge = async (
    params: CamelCasedProperties<
      Extract<
        ExecuteMsg,
        {
          update_friends_for_challenge: unknown
        }
      >['update_friends_for_challenge']
    >,
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return this._execute(
      ChallengeExecuteMsgBuilder.updateFriendsForChallenge(params),
      fee,
      memo,
      _funds,
    )
  }
  castVote = async (
    params: CamelCasedProperties<
      Extract<
        ExecuteMsg,
        {
          cast_vote: unknown
        }
      >['cast_vote']
    >,
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return this._execute(
      ChallengeExecuteMsgBuilder.castVote(params),
      fee,
      memo,
      _funds,
    )
  }
  countVotes = async (
    params: CamelCasedProperties<
      Extract<
        ExecuteMsg,
        {
          count_votes: unknown
        }
      >['count_votes']
    >,
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return this._execute(
      ChallengeExecuteMsgBuilder.countVotes(params),
      fee,
      memo,
      _funds,
    )
  }
  veto = async (
    params: CamelCasedProperties<
      Extract<
        ExecuteMsg,
        {
          veto: unknown
        }
      >['veto']
    >,
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    return this._execute(
      ChallengeExecuteMsgBuilder.veto(params),
      fee,
      memo,
      _funds,
    )
  }
  _execute = async (
    msg: ExecuteMsg,
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[],
  ): Promise<ExecuteResult> => {
    const moduleMsg: AppExecuteMsg<ExecuteMsg> =
      AppExecuteMsgFactory.executeApp(msg)
    return await this.accountClient.abstract.client.execute(
      this.accountClient.sender,
      await this.address(),
      moduleMsg,
      fee,
      memo,
      _funds,
    )
  }
}
