/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.28.0.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import {
  type UseQueryOptions,
  useQuery,
  useMutation,
  type UseMutationOptions,
} from '@tanstack/react-query'
import { type ExecuteResult } from '@cosmjs/cosmwasm-stargate'
import { type StdFee } from '@cosmjs/amino'
import {
  Uint128,
  InstantiateMsg,
  type Coin,
  ExecuteMsg,
  type Namespace,
  ModuleVersion,
  ModuleReference,
  Addr,
  type Monetization,
  type Action,
  Expiration,
  Timestamp,
  Uint64,
  type ModuleInfo,
  FixedFee,
  type AccountBase,
  QueryMsg,
  ModuleStatus,
  type ModuleFilter,
  MigrateMsg,
  type AccountBaseResponse,
  type ConfigResponse,
  type ModulesListResponse,
  ModuleResponse,
  ModuleConfiguration,
  Module,
  type ModulesResponse,
  type NamespaceResponse,
  type NamespaceListResponse,
  type NamespacesResponse,
  type OwnershipForString,
} from '@abstract-money/abstract.js/lib/native/registry/Registry.types'
import { RegistryClient, RegistryQueryClient } from '@abstract-money/abstract.js'

export const registryQueryKeys = {
  contract: [
    {
      contract: 'registry',
    },
  ] as const,
  address: (contractAddress: string | undefined) =>
    [{ ...registryQueryKeys.contract[0], address: contractAddress }] as const,
  accountBase: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...registryQueryKeys.address(contractAddress)[0], method: 'account_base', args }] as const,
  modules: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...registryQueryKeys.address(contractAddress)[0], method: 'modules', args }] as const,
  namespaces: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...registryQueryKeys.address(contractAddress)[0], method: 'namespaces', args }] as const,
  namespace: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...registryQueryKeys.address(contractAddress)[0], method: 'namespace', args }] as const,
  config: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...registryQueryKeys.address(contractAddress)[0], method: 'config', args }] as const,
  moduleList: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...registryQueryKeys.address(contractAddress)[0], method: 'module_list', args }] as const,
  namespaceList: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...registryQueryKeys.address(contractAddress)[0], method: 'namespace_list', args }] as const,
  ownership: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...registryQueryKeys.address(contractAddress)[0], method: 'ownership', args }] as const,
}
export const registryQueries = {
  accountBase: <TData = AccountBaseResponse>({
    client,
    args,
    options,
  }: RegistryAccountBaseQuery<TData>): UseQueryOptions<AccountBaseResponse, Error, TData> => ({
    queryKey: registryQueryKeys.accountBase(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.accountBase({
            accountId: args.accountId,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  modules: <TData = ModulesResponse>({
    client,
    args,
    options,
  }: RegistryModulesQuery<TData>): UseQueryOptions<ModulesResponse, Error, TData> => ({
    queryKey: registryQueryKeys.modules(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.modules({
            infos: args.infos,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  namespaces: <TData = NamespacesResponse>({
    client,
    args,
    options,
  }: RegistryNamespacesQuery<TData>): UseQueryOptions<NamespacesResponse, Error, TData> => ({
    queryKey: registryQueryKeys.namespaces(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.namespaces({
            accounts: args.accounts,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  namespace: <TData = NamespaceResponse>({
    client,
    args,
    options,
  }: RegistryNamespaceQuery<TData>): UseQueryOptions<NamespaceResponse, Error, TData> => ({
    queryKey: registryQueryKeys.namespace(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.namespace({
            namespace: args.namespace,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  config: <TData = ConfigResponse>({
    client,
    options,
  }: RegistryConfigQuery<TData>): UseQueryOptions<ConfigResponse, Error, TData> => ({
    queryKey: registryQueryKeys.config(client?.contractAddress),
    queryFn: () => (client ? client.config() : Promise.reject(new Error('Invalid client'))),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  moduleList: <TData = ModulesListResponse>({
    client,
    args,
    options,
  }: RegistryModuleListQuery<TData>): UseQueryOptions<ModulesListResponse, Error, TData> => ({
    queryKey: registryQueryKeys.moduleList(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.moduleList({
            filter: args.filter,
            limit: args.limit,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  namespaceList: <TData = NamespaceListResponse>({
    client,
    args,
    options,
  }: RegistryNamespaceListQuery<TData>): UseQueryOptions<NamespaceListResponse, Error, TData> => ({
    queryKey: registryQueryKeys.namespaceList(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.namespaceList({
            limit: args.limit,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  ownership: <TData = OwnershipForString>({
    client,
    options,
  }: RegistryOwnershipQuery<TData>): UseQueryOptions<OwnershipForString, Error, TData> => ({
    queryKey: registryQueryKeys.ownership(client?.contractAddress),
    queryFn: () => (client ? client.ownership() : Promise.reject(new Error('Invalid client'))),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
}
export interface RegistryReactQuery<TResponse, TData = TResponse> {
  client: RegistryQueryClient | undefined
  options?: Omit<
    UseQueryOptions<TResponse, Error, TData>,
    "'queryKey' | 'queryFn' | 'initialData'"
  > & {
    initialData?: undefined
  }
}
export interface RegistryOwnershipQuery<TData>
  extends RegistryReactQuery<OwnershipForString, TData> {}
export function useRegistryOwnershipQuery<TData = OwnershipForString>({
  client,
  options,
}: RegistryOwnershipQuery<TData>) {
  return useQuery<OwnershipForString, Error, TData>(
    registryQueryKeys.ownership(client?.contractAddress),
    () => (client ? client.ownership() : Promise.reject(new Error('Invalid client'))),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface RegistryNamespaceListQuery<TData>
  extends RegistryReactQuery<NamespaceListResponse, TData> {
  args: {
    limit?: number
    startAfter?: string
  }
}
export function useRegistryNamespaceListQuery<TData = NamespaceListResponse>({
  client,
  args,
  options,
}: RegistryNamespaceListQuery<TData>) {
  return useQuery<NamespaceListResponse, Error, TData>(
    registryQueryKeys.namespaceList(client?.contractAddress, args),
    () =>
      client
        ? client.namespaceList({
            limit: args.limit,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface RegistryModuleListQuery<TData>
  extends RegistryReactQuery<ModulesListResponse, TData> {
  args: {
    filter?: ModuleFilter
    limit?: number
    startAfter?: ModuleInfo
  }
}
export function useRegistryModuleListQuery<TData = ModulesListResponse>({
  client,
  args,
  options,
}: RegistryModuleListQuery<TData>) {
  return useQuery<ModulesListResponse, Error, TData>(
    registryQueryKeys.moduleList(client?.contractAddress, args),
    () =>
      client
        ? client.moduleList({
            filter: args.filter,
            limit: args.limit,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface RegistryConfigQuery<TData> extends RegistryReactQuery<ConfigResponse, TData> {}
export function useRegistryConfigQuery<TData = ConfigResponse>({
  client,
  options,
}: RegistryConfigQuery<TData>) {
  return useQuery<ConfigResponse, Error, TData>(
    registryQueryKeys.config(client?.contractAddress),
    () => (client ? client.config() : Promise.reject(new Error('Invalid client'))),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface RegistryNamespaceQuery<TData>
  extends RegistryReactQuery<NamespaceResponse, TData> {
  args: {
    namespace: Namespace
  }
}
export function useRegistryNamespaceQuery<TData = NamespaceResponse>({
  client,
  args,
  options,
}: RegistryNamespaceQuery<TData>) {
  return useQuery<NamespaceResponse, Error, TData>(
    registryQueryKeys.namespace(client?.contractAddress, args),
    () =>
      client
        ? client.namespace({
            namespace: args.namespace,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface RegistryNamespacesQuery<TData>
  extends RegistryReactQuery<NamespacesResponse, TData> {
  args: {
    accounts: number[]
  }
}
export function useRegistryNamespacesQuery<TData = NamespacesResponse>({
  client,
  args,
  options,
}: RegistryNamespacesQuery<TData>) {
  return useQuery<NamespacesResponse, Error, TData>(
    registryQueryKeys.namespaces(client?.contractAddress, args),
    () =>
      client
        ? client.namespaces({
            accounts: args.accounts,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface RegistryModulesQuery<TData> extends RegistryReactQuery<ModulesResponse, TData> {
  args: {
    infos: ModuleInfo[]
  }
}
export function useRegistryModulesQuery<TData = ModulesResponse>({
  client,
  args,
  options,
}: RegistryModulesQuery<TData>) {
  return useQuery<ModulesResponse, Error, TData>(
    registryQueryKeys.modules(client?.contractAddress, args),
    () =>
      client
        ? client.modules({
            infos: args.infos,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface RegistryAccountBaseQuery<TData>
  extends RegistryReactQuery<AccountBaseResponse, TData> {
  args: {
    accountId: number
  }
}
export function useRegistryAccountBaseQuery<TData = AccountBaseResponse>({
  client,
  args,
  options,
}: RegistryAccountBaseQuery<TData>) {
  return useQuery<AccountBaseResponse, Error, TData>(
    registryQueryKeys.accountBase(client?.contractAddress, args),
    () =>
      client
        ? client.accountBase({
            accountId: args.accountId,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface RegistryUpdateOwnershipMutation {
  client: RegistryClient
  msg: Action
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useRegistryUpdateOwnershipMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, RegistryUpdateOwnershipMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, RegistryUpdateOwnershipMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.updateOwnership(msg, fee, memo, funds),
    options
  )
}
export interface RegistrySetFactoryMutation {
  client: RegistryClient
  msg: {
    newFactory: string
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useRegistrySetFactoryMutation(
  options?: Omit<UseMutationOptions<ExecuteResult, Error, RegistrySetFactoryMutation>, 'mutationFn'>
) {
  return useMutation<ExecuteResult, Error, RegistrySetFactoryMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) => client.setFactory(msg, fee, memo, funds),
    options
  )
}
export interface RegistryUpdateConfigMutation {
  client: RegistryClient
  msg: {
    allowDirectModuleRegistrationAndUpdates?: boolean
    namespaceRegistrationFee?: Coin
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useRegistryUpdateConfigMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, RegistryUpdateConfigMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, RegistryUpdateConfigMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.updateConfig(msg, fee, memo, funds),
    options
  )
}
export interface RegistryAddAccountMutation {
  client: RegistryClient
  msg: {
    accountBase: AccountBase
    accountId: number
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useRegistryAddAccountMutation(
  options?: Omit<UseMutationOptions<ExecuteResult, Error, RegistryAddAccountMutation>, 'mutationFn'>
) {
  return useMutation<ExecuteResult, Error, RegistryAddAccountMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) => client.addAccount(msg, fee, memo, funds),
    options
  )
}
export interface RegistryRemoveNamespacesMutation {
  client: RegistryClient
  msg: {
    namespaces: string[]
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useRegistryRemoveNamespacesMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, RegistryRemoveNamespacesMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, RegistryRemoveNamespacesMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.removeNamespaces(msg, fee, memo, funds),
    options
  )
}
export interface RegistryClaimNamespaceMutation {
  client: RegistryClient
  msg: {
    accountId: number
    namespace: string
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useRegistryClaimNamespaceMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, RegistryClaimNamespaceMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, RegistryClaimNamespaceMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.claimNamespace(msg, fee, memo, funds),
    options
  )
}
export interface RegistryApproveOrRejectModulesMutation {
  client: RegistryClient
  msg: {
    approves: ModuleInfo[]
    rejects: ModuleInfo[]
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useRegistryApproveOrRejectModulesMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, RegistryApproveOrRejectModulesMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, RegistryApproveOrRejectModulesMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.approveOrRejectModules(msg, fee, memo, funds),
    options
  )
}
export interface RegistrySetModuleMetadataMutation {
  client: RegistryClient
  msg: {
    metadata: string
    module: ModuleInfo
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useRegistrySetModuleMetadataMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, RegistrySetModuleMetadataMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, RegistrySetModuleMetadataMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.setModuleMetadata(msg, fee, memo, funds),
    options
  )
}
export interface RegistrySetModuleMonetizationMutation {
  client: RegistryClient
  msg: {
    moduleName: string
    monetization: Monetization
    namespace: Namespace
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useRegistrySetModuleMonetizationMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, RegistrySetModuleMonetizationMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, RegistrySetModuleMonetizationMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.setModuleMonetization(msg, fee, memo, funds),
    options
  )
}
export interface RegistryProposeModulesMutation {
  client: RegistryClient
  msg: {
    modules: ModuleInfo[][]
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useRegistryProposeModulesMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, RegistryProposeModulesMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, RegistryProposeModulesMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.proposeModules(msg, fee, memo, funds),
    options
  )
}
export interface RegistryYankModuleMutation {
  client: RegistryClient
  msg: {
    module: ModuleInfo
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useRegistryYankModuleMutation(
  options?: Omit<UseMutationOptions<ExecuteResult, Error, RegistryYankModuleMutation>, 'mutationFn'>
) {
  return useMutation<ExecuteResult, Error, RegistryYankModuleMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) => client.yankModule(msg, fee, memo, funds),
    options
  )
}
export interface RegistryRemoveModuleMutation {
  client: RegistryClient
  msg: {
    module: ModuleInfo
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useRegistryRemoveModuleMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, RegistryRemoveModuleMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, RegistryRemoveModuleMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.removeModule(msg, fee, memo, funds),
    options
  )
}
