/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.28.0.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import {
  type UseQueryOptions,
  useQuery,
  useMutation,
  type UseMutationOptions,
} from '@tanstack/react-query'
import { type ExecuteResult } from '@cosmjs/cosmwasm-stargate'
import { type StdFee, type Coin } from '@cosmjs/amino'
import {
  InstantiateMsg,
  ExecuteMsg,
  type AssetInfoBaseForString,
  type PoolAddressBaseForString,
  AssetEntry,
  PoolType,
  type UniquePoolId,
  type Action,
  Expiration,
  Timestamp,
  Uint64,
  type UncheckedContractEntry,
  type UncheckedChannelEntry,
  PoolMetadata,
  QueryMsg,
  type DexAssetPairing,
  type AssetFilter,
  type AssetInfoFilter,
  type ContractEntry,
  type ContractFilter,
  type ChannelEntry,
  type ChannelFilter,
  type AssetPairingFilter,
  type PoolMetadataFilter,
  MigrateMsg,
  AssetInfoBaseForAddr,
  Addr,
  type AssetInfoListResponse,
  type AssetsResponse,
  type AssetListResponse,
  type ChannelListResponse,
  type ChannelsResponse,
  type ConfigResponse,
  type ContractListResponse,
  type ContractsResponse,
  type OwnershipForString,
  PoolAddressBaseForAddr,
  type PoolAddressListResponse,
  PoolReference,
  type PoolMetadataListResponse,
  type PoolMetadatasResponse,
  type PoolsResponse,
  type RegisteredDexesResponse,
} from '@abstract-money/abstract.js/lib/native/ans-host/AnsHost.types'
import { type AnsHostClient, type AnsHostQueryClient } from '@abstract-money/abstract.js'
export const ansHostQueryKeys = {
  contract: [
    {
      contract: 'ansHost',
    },
  ] as const,
  address: (contractAddress: string | undefined) =>
    [{ ...ansHostQueryKeys.contract[0], address: contractAddress }] as const,
  config: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...ansHostQueryKeys.address(contractAddress)[0], method: 'config', args }] as const,
  assets: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...ansHostQueryKeys.address(contractAddress)[0], method: 'assets', args }] as const,
  assetList: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...ansHostQueryKeys.address(contractAddress)[0], method: 'asset_list', args }] as const,
  assetInfos: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...ansHostQueryKeys.address(contractAddress)[0], method: 'asset_infos', args }] as const,
  assetInfoList: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...ansHostQueryKeys.address(contractAddress)[0], method: 'asset_info_list', args }] as const,
  contracts: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...ansHostQueryKeys.address(contractAddress)[0], method: 'contracts', args }] as const,
  contractList: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...ansHostQueryKeys.address(contractAddress)[0], method: 'contract_list', args }] as const,
  channels: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...ansHostQueryKeys.address(contractAddress)[0], method: 'channels', args }] as const,
  channelList: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...ansHostQueryKeys.address(contractAddress)[0], method: 'channel_list', args }] as const,
  registeredDexes: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [
      { ...ansHostQueryKeys.address(contractAddress)[0], method: 'registered_dexes', args },
    ] as const,
  pools: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...ansHostQueryKeys.address(contractAddress)[0], method: 'pools', args }] as const,
  poolList: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...ansHostQueryKeys.address(contractAddress)[0], method: 'pool_list', args }] as const,
  poolMetadatas: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...ansHostQueryKeys.address(contractAddress)[0], method: 'pool_metadatas', args }] as const,
  poolMetadataList: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [
      { ...ansHostQueryKeys.address(contractAddress)[0], method: 'pool_metadata_list', args },
    ] as const,
  ownership: (contractAddress: string | undefined, args?: Record<string, unknown>) =>
    [{ ...ansHostQueryKeys.address(contractAddress)[0], method: 'ownership', args }] as const,
}
export const ansHostQueries = {
  config: <TData = ConfigResponse>({
    client,
    options,
  }: AnsHostConfigQuery<TData>): UseQueryOptions<ConfigResponse, Error, TData> => ({
    queryKey: ansHostQueryKeys.config(client?.contractAddress),
    queryFn: () => (client ? client.config() : Promise.reject(new Error('Invalid client'))),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  assets: <TData = AssetsResponse>({
    client,
    args,
    options,
  }: AnsHostAssetsQuery<TData>): UseQueryOptions<AssetsResponse, Error, TData> => ({
    queryKey: ansHostQueryKeys.assets(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.assets({
            names: args.names,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  assetList: <TData = AssetListResponse>({
    client,
    args,
    options,
  }: AnsHostAssetListQuery<TData>): UseQueryOptions<AssetListResponse, Error, TData> => ({
    queryKey: ansHostQueryKeys.assetList(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.assetList({
            filter: args.filter,
            limit: args.limit,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  assetInfos: <TData = AssetsResponse>({
    client,
    args,
    options,
  }: AnsHostAssetInfosQuery<TData>): UseQueryOptions<AssetsResponse, Error, TData> => ({
    queryKey: ansHostQueryKeys.assetInfos(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.assetInfos({
            infos: args.infos,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  assetInfoList: <TData = AssetInfoListResponse>({
    client,
    args,
    options,
  }: AnsHostAssetInfoListQuery<TData>): UseQueryOptions<AssetInfoListResponse, Error, TData> => ({
    queryKey: ansHostQueryKeys.assetInfoList(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.assetInfoList({
            filter: args.filter,
            limit: args.limit,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  contracts: <TData = ContractsResponse>({
    client,
    args,
    options,
  }: AnsHostContractsQuery<TData>): UseQueryOptions<ContractsResponse, Error, TData> => ({
    queryKey: ansHostQueryKeys.contracts(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.contracts({
            entries: args.entries,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  contractList: <TData = ContractListResponse>({
    client,
    args,
    options,
  }: AnsHostContractListQuery<TData>): UseQueryOptions<ContractListResponse, Error, TData> => ({
    queryKey: ansHostQueryKeys.contractList(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.contractList({
            filter: args.filter,
            limit: args.limit,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  channels: <TData = ChannelsResponse>({
    client,
    args,
    options,
  }: AnsHostChannelsQuery<TData>): UseQueryOptions<ChannelsResponse, Error, TData> => ({
    queryKey: ansHostQueryKeys.channels(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.channels({
            entries: args.entries,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  channelList: <TData = ChannelListResponse>({
    client,
    args,
    options,
  }: AnsHostChannelListQuery<TData>): UseQueryOptions<ChannelListResponse, Error, TData> => ({
    queryKey: ansHostQueryKeys.channelList(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.channelList({
            filter: args.filter,
            limit: args.limit,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  registeredDexes: <TData = RegisteredDexesResponse>({
    client,
    options,
  }: AnsHostRegisteredDexesQuery<TData>): UseQueryOptions<
    RegisteredDexesResponse,
    Error,
    TData
  > => ({
    queryKey: ansHostQueryKeys.registeredDexes(client?.contractAddress),
    queryFn: () =>
      client ? client.registeredDexes() : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  pools: <TData = PoolsResponse>({
    client,
    args,
    options,
  }: AnsHostPoolsQuery<TData>): UseQueryOptions<PoolsResponse, Error, TData> => ({
    queryKey: ansHostQueryKeys.pools(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.pools({
            pairings: args.pairings,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  poolList: <TData = PoolAddressListResponse>({
    client,
    args,
    options,
  }: AnsHostPoolListQuery<TData>): UseQueryOptions<PoolAddressListResponse, Error, TData> => ({
    queryKey: ansHostQueryKeys.poolList(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.poolList({
            filter: args.filter,
            limit: args.limit,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  poolMetadatas: <TData = PoolMetadatasResponse>({
    client,
    args,
    options,
  }: AnsHostPoolMetadatasQuery<TData>): UseQueryOptions<PoolMetadatasResponse, Error, TData> => ({
    queryKey: ansHostQueryKeys.poolMetadatas(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.poolMetadatas({
            ids: args.ids,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  poolMetadataList: <TData = PoolMetadataListResponse>({
    client,
    args,
    options,
  }: AnsHostPoolMetadataListQuery<TData>): UseQueryOptions<
    PoolMetadataListResponse,
    Error,
    TData
  > => ({
    queryKey: ansHostQueryKeys.poolMetadataList(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.poolMetadataList({
            filter: args.filter,
            limit: args.limit,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error('Invalid client')),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  ownership: <TData = OwnershipForString>({
    client,
    options,
  }: AnsHostOwnershipQuery<TData>): UseQueryOptions<OwnershipForString, Error, TData> => ({
    queryKey: ansHostQueryKeys.ownership(client?.contractAddress),
    queryFn: () => (client ? client.ownership() : Promise.reject(new Error('Invalid client'))),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
}
export interface AnsHostReactQuery<TResponse, TData = TResponse> {
  client: AnsHostQueryClient | undefined
  options?: Omit<
    UseQueryOptions<TResponse, Error, TData>,
    "'queryKey' | 'queryFn' | 'initialData'"
  > & {
    initialData?: undefined
  }
}
export interface AnsHostOwnershipQuery<TData>
  extends AnsHostReactQuery<OwnershipForString, TData> {}
export function useAnsHostOwnershipQuery<TData = OwnershipForString>({
  client,
  options,
}: AnsHostOwnershipQuery<TData>) {
  return useQuery<OwnershipForString, Error, TData>(
    ansHostQueryKeys.ownership(client?.contractAddress),
    () => (client ? client.ownership() : Promise.reject(new Error('Invalid client'))),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface AnsHostPoolMetadataListQuery<TData>
  extends AnsHostReactQuery<PoolMetadataListResponse, TData> {
  args: {
    filter?: PoolMetadataFilter
    limit?: number
    startAfter?: UniquePoolId
  }
}
export function useAnsHostPoolMetadataListQuery<TData = PoolMetadataListResponse>({
  client,
  args,
  options,
}: AnsHostPoolMetadataListQuery<TData>) {
  return useQuery<PoolMetadataListResponse, Error, TData>(
    ansHostQueryKeys.poolMetadataList(client?.contractAddress, args),
    () =>
      client
        ? client.poolMetadataList({
            filter: args.filter,
            limit: args.limit,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface AnsHostPoolMetadatasQuery<TData>
  extends AnsHostReactQuery<PoolMetadatasResponse, TData> {
  args: {
    ids: UniquePoolId[]
  }
}
export function useAnsHostPoolMetadatasQuery<TData = PoolMetadatasResponse>({
  client,
  args,
  options,
}: AnsHostPoolMetadatasQuery<TData>) {
  return useQuery<PoolMetadatasResponse, Error, TData>(
    ansHostQueryKeys.poolMetadatas(client?.contractAddress, args),
    () =>
      client
        ? client.poolMetadatas({
            ids: args.ids,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface AnsHostPoolListQuery<TData>
  extends AnsHostReactQuery<PoolAddressListResponse, TData> {
  args: {
    filter?: AssetPairingFilter
    limit?: number
    startAfter?: DexAssetPairing
  }
}
export function useAnsHostPoolListQuery<TData = PoolAddressListResponse>({
  client,
  args,
  options,
}: AnsHostPoolListQuery<TData>) {
  return useQuery<PoolAddressListResponse, Error, TData>(
    ansHostQueryKeys.poolList(client?.contractAddress, args),
    () =>
      client
        ? client.poolList({
            filter: args.filter,
            limit: args.limit,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface AnsHostPoolsQuery<TData> extends AnsHostReactQuery<PoolsResponse, TData> {
  args: {
    pairings: DexAssetPairing[]
  }
}
export function useAnsHostPoolsQuery<TData = PoolsResponse>({
  client,
  args,
  options,
}: AnsHostPoolsQuery<TData>) {
  return useQuery<PoolsResponse, Error, TData>(
    ansHostQueryKeys.pools(client?.contractAddress, args),
    () =>
      client
        ? client.pools({
            pairings: args.pairings,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface AnsHostRegisteredDexesQuery<TData>
  extends AnsHostReactQuery<RegisteredDexesResponse, TData> {}
export function useAnsHostRegisteredDexesQuery<TData = RegisteredDexesResponse>({
  client,
  options,
}: AnsHostRegisteredDexesQuery<TData>) {
  return useQuery<RegisteredDexesResponse, Error, TData>(
    ansHostQueryKeys.registeredDexes(client?.contractAddress),
    () => (client ? client.registeredDexes() : Promise.reject(new Error('Invalid client'))),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface AnsHostChannelListQuery<TData>
  extends AnsHostReactQuery<ChannelListResponse, TData> {
  args: {
    filter?: ChannelFilter
    limit?: number
    startAfter?: ChannelEntry
  }
}
export function useAnsHostChannelListQuery<TData = ChannelListResponse>({
  client,
  args,
  options,
}: AnsHostChannelListQuery<TData>) {
  return useQuery<ChannelListResponse, Error, TData>(
    ansHostQueryKeys.channelList(client?.contractAddress, args),
    () =>
      client
        ? client.channelList({
            filter: args.filter,
            limit: args.limit,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface AnsHostChannelsQuery<TData> extends AnsHostReactQuery<ChannelsResponse, TData> {
  args: {
    entries: ChannelEntry[]
  }
}
export function useAnsHostChannelsQuery<TData = ChannelsResponse>({
  client,
  args,
  options,
}: AnsHostChannelsQuery<TData>) {
  return useQuery<ChannelsResponse, Error, TData>(
    ansHostQueryKeys.channels(client?.contractAddress, args),
    () =>
      client
        ? client.channels({
            entries: args.entries,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface AnsHostContractListQuery<TData>
  extends AnsHostReactQuery<ContractListResponse, TData> {
  args: {
    filter?: ContractFilter
    limit?: number
    startAfter?: ContractEntry
  }
}
export function useAnsHostContractListQuery<TData = ContractListResponse>({
  client,
  args,
  options,
}: AnsHostContractListQuery<TData>) {
  return useQuery<ContractListResponse, Error, TData>(
    ansHostQueryKeys.contractList(client?.contractAddress, args),
    () =>
      client
        ? client.contractList({
            filter: args.filter,
            limit: args.limit,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface AnsHostContractsQuery<TData> extends AnsHostReactQuery<ContractsResponse, TData> {
  args: {
    entries: ContractEntry[]
  }
}
export function useAnsHostContractsQuery<TData = ContractsResponse>({
  client,
  args,
  options,
}: AnsHostContractsQuery<TData>) {
  return useQuery<ContractsResponse, Error, TData>(
    ansHostQueryKeys.contracts(client?.contractAddress, args),
    () =>
      client
        ? client.contracts({
            entries: args.entries,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface AnsHostAssetInfoListQuery<TData>
  extends AnsHostReactQuery<AssetInfoListResponse, TData> {
  args: {
    filter?: AssetInfoFilter
    limit?: number
    startAfter?: AssetInfoBaseForString
  }
}
export function useAnsHostAssetInfoListQuery<TData = AssetInfoListResponse>({
  client,
  args,
  options,
}: AnsHostAssetInfoListQuery<TData>) {
  return useQuery<AssetInfoListResponse, Error, TData>(
    ansHostQueryKeys.assetInfoList(client?.contractAddress, args),
    () =>
      client
        ? client.assetInfoList({
            filter: args.filter,
            limit: args.limit,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface AnsHostAssetInfosQuery<TData> extends AnsHostReactQuery<AssetsResponse, TData> {
  args: {
    infos: AssetInfoBaseForString[]
  }
}
export function useAnsHostAssetInfosQuery<TData = AssetsResponse>({
  client,
  args,
  options,
}: AnsHostAssetInfosQuery<TData>) {
  return useQuery<AssetsResponse, Error, TData>(
    ansHostQueryKeys.assetInfos(client?.contractAddress, args),
    () =>
      client
        ? client.assetInfos({
            infos: args.infos,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface AnsHostAssetListQuery<TData> extends AnsHostReactQuery<AssetListResponse, TData> {
  args: {
    filter?: AssetFilter
    limit?: number
    startAfter?: string
  }
}
export function useAnsHostAssetListQuery<TData = AssetListResponse>({
  client,
  args,
  options,
}: AnsHostAssetListQuery<TData>) {
  return useQuery<AssetListResponse, Error, TData>(
    ansHostQueryKeys.assetList(client?.contractAddress, args),
    () =>
      client
        ? client.assetList({
            filter: args.filter,
            limit: args.limit,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface AnsHostAssetsQuery<TData> extends AnsHostReactQuery<AssetsResponse, TData> {
  args: {
    names: string[]
  }
}
export function useAnsHostAssetsQuery<TData = AssetsResponse>({
  client,
  args,
  options,
}: AnsHostAssetsQuery<TData>) {
  return useQuery<AssetsResponse, Error, TData>(
    ansHostQueryKeys.assets(client?.contractAddress, args),
    () =>
      client
        ? client.assets({
            names: args.names,
          })
        : Promise.reject(new Error('Invalid client')),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface AnsHostConfigQuery<TData> extends AnsHostReactQuery<ConfigResponse, TData> {}
export function useAnsHostConfigQuery<TData = ConfigResponse>({
  client,
  options,
}: AnsHostConfigQuery<TData>) {
  return useQuery<ConfigResponse, Error, TData>(
    ansHostQueryKeys.config(client?.contractAddress),
    () => (client ? client.config() : Promise.reject(new Error('Invalid client'))),
    { ...options, enabled: !!client && (options?.enabled != undefined ? options.enabled : true) }
  )
}
export interface AnsHostUpdateOwnershipMutation {
  client: AnsHostClient
  msg: Action
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useAnsHostUpdateOwnershipMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, AnsHostUpdateOwnershipMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, AnsHostUpdateOwnershipMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.updateOwnership(msg, fee, memo, funds),
    options
  )
}
export interface AnsHostUpdatePoolsMutation {
  client: AnsHostClient
  msg: {
    toAdd: PoolAddressBaseForString[][]
    toRemove: UniquePoolId[]
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useAnsHostUpdatePoolsMutation(
  options?: Omit<UseMutationOptions<ExecuteResult, Error, AnsHostUpdatePoolsMutation>, 'mutationFn'>
) {
  return useMutation<ExecuteResult, Error, AnsHostUpdatePoolsMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) => client.updatePools(msg, fee, memo, funds),
    options
  )
}
export interface AnsHostUpdateDexesMutation {
  client: AnsHostClient
  msg: {
    toAdd: string[]
    toRemove: string[]
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useAnsHostUpdateDexesMutation(
  options?: Omit<UseMutationOptions<ExecuteResult, Error, AnsHostUpdateDexesMutation>, 'mutationFn'>
) {
  return useMutation<ExecuteResult, Error, AnsHostUpdateDexesMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) => client.updateDexes(msg, fee, memo, funds),
    options
  )
}
export interface AnsHostUpdateChannelsMutation {
  client: AnsHostClient
  msg: {
    toAdd: UncheckedChannelEntry[][]
    toRemove: UncheckedChannelEntry[]
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useAnsHostUpdateChannelsMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, AnsHostUpdateChannelsMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, AnsHostUpdateChannelsMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.updateChannels(msg, fee, memo, funds),
    options
  )
}
export interface AnsHostUpdateAssetAddressesMutation {
  client: AnsHostClient
  msg: {
    toAdd: string[][]
    toRemove: string[]
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useAnsHostUpdateAssetAddressesMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, AnsHostUpdateAssetAddressesMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, AnsHostUpdateAssetAddressesMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.updateAssetAddresses(msg, fee, memo, funds),
    options
  )
}
export interface AnsHostUpdateContractAddressesMutation {
  client: AnsHostClient
  msg: {
    toAdd: UncheckedContractEntry[][]
    toRemove: UncheckedContractEntry[]
  }
  args?: {
    fee?: number | StdFee | 'auto'
    memo?: string
    funds?: Coin[]
  }
}
export function useAnsHostUpdateContractAddressesMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, AnsHostUpdateContractAddressesMutation>,
    'mutationFn'
  >
) {
  return useMutation<ExecuteResult, Error, AnsHostUpdateContractAddressesMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.updateContractAddresses(msg, fee, memo, funds),
    options
  )
}
